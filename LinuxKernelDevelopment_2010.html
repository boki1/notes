
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Linux Kernel Development &#8212; Notes  documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.e2363ea40746bee74734a24ffefccd78.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Little Book Of Semaphores" href="LittleBookOfSemaphore.html" />
    <link rel="prev" title="&lt;no title&gt;" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Notes  documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p class="caption" role="heading">
 <span class="caption-text">
  Books
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Linux Kernel Development
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="LittleBookOfSemaphore.html">
   The Little Book Of Semaphores
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Papers
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ObjectCachingKernelSlabAllocator.html">
   The Slab Allocator: An Object Caching Kernel Memory Allocator
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/LinuxKernelDevelopment_2010.rst.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.rst</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#process-management">
   Process Management
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creation">
     Creation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#termination">
     Termination
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#process-scheduling">
   Process Scheduling
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scheduler-policy">
     Scheduler Policy
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#prioritizing">
     Prioritizing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#timeslices">
     Timeslices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#desired-results-of-cfs">
     Desired Results of CFS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#completely-fair-scheduling-algorithm">
     Completely Fair Scheduling Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implementation">
     Implementation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#waiting-and-waking-up">
     Waiting and Waking-Up
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preemption-and-context-switching">
     Preemption and Context Switching
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#real-time-scheduling-policies">
     Real-Time Scheduling Policies
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#system-calls">
   System Calls
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kernel-data-structures">
   Kernel Data Structures
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#linked-lists">
     Linked Lists
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#queues">
     Queues
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#maps">
     Maps
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#trees">
     Trees
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interrupt-handling">
   Interrupt Handling
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bottom-halves">
     Bottom halves
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#work-queues">
     Work Queues
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kernel-synchronisation">
   Kernel Synchronisation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general">
     General
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#primitives">
     Primitives
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#timers-and-time-management">
   Timers and Time Management
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#memory-management">
   Memory Management
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#allocating-memory">
     Allocating memory
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#slab-layer">
     Slab Layer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtual-filesystem">
   Virtual Filesystem
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#summary">
     Summary
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#superblock">
     Superblock
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#inode">
     Inode
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dentry">
     Dentry
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#file">
     File
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filesystem-related-structs">
     Filesystem Related Structs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#process-related-structs">
     Process Related Structs
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#block-i-o">
   Block I/O
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-device">
     Block Device
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#buffer">
     Buffer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bio">
     Bio
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#i-o-scheduler">
     I/O Scheduler
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#process-address-space">
   Process Address Space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#page-cache">
   Page Cache
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#devices-and-sysfs">
   Devices and sysfs
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="linux-kernel-development">
<h1>Linux Kernel Development<a class="headerlink" href="#linux-kernel-development" title="Permalink to this headline">¶</a></h1>
<p><em>Robert Love, 2010</em></p>
<a class="reference internal image-reference" href="_images/cover.jpg"><img alt="_images/cover.jpg" class="align-center" src="_images/cover.jpg" style="width: 233.39999999999998px; height: 300.0px;" /></a>
<div class="section" id="process-management">
<h2>Process Management<a class="headerlink" href="#process-management" title="Permalink to this headline">¶</a></h2>
<p>The kernel does not an internal representation for threads. Actually it does not find threads to be that different then processes.</p>
<p>All processes are stored in a doubly-linked list where each element is a descriptor of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span></code>. Additionally each processes gets assigned an opaque unique identification called pid <a class="footnote-reference brackets" href="#f1" id="id1">1</a>, which is used as an indexk</p>
<a class="reference internal image-reference" href="_images/struct_task_list.png"><img alt="_images/struct_task_list.png" src="_images/struct_task_list.png" style="width: 546.4px; height: 428.8px;" /></a>
<p>Usually when the kernel operates on processes, it accesses directly the <code class="docutils literal notranslate"><span class="pre">task_struct</span></code> of the target process. It is quite common to edit the values associated with a certain process, often that is the currently executing process. Henceforth, a mechanism for acquiring it is provided - the <code class="docutils literal notranslate"><span class="pre">current()</span></code> macro. Its implementation is architechture specific and depends on other factors discussed later.</p>
<p>In order to access the <code class="docutils literal notranslate"><span class="pre">task_struct</span></code> of a process, firstly the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">thread_info</span></code> must be acquired and then access the other, which is pointed by one of the members of <code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">info</span></code>. It is usually stored at the bottom or the top of the kernel stack, or a pointer to it is stored in a register, depending on the specific arch.</p>
<p>Each process is in exactly one of the following states:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> - The task is in the run queue, meaning that it is either runable or actually running</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - The task is blocked and resides in a wait queue and awaits for a specific event, which will <em>interrupt</em> its sleep. Also, if it receives a signal, it might awake prematurely.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - Same as previous but cannot wake up prematurely.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__TASK_TRACED</span></code> - The task is being traced.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__TASK_STOPPED</span></code> - The task is not allowed to execute. Usually follows a <code class="docutils literal notranslate"><span class="pre">SIGSTOP</span></code> or similar.</p></li>
</ul>
</div></blockquote>
<p>The transition is illustrated here:</p>
<a class="reference internal image-reference" href="_images/process_state_flow.png"><img alt="_images/process_state_flow.png" src="_images/process_state_flow.png" style="width: 624.6px; height: 472.79999999999995px;" /></a>
<p>The process state could be modified by the <code class="docutils literal notranslate"><span class="pre">set_task_task()</span></code> and <code class="docutils literal notranslate"><span class="pre">__set_task_state()</span></code> macros.</p>
<p>The first process (<code class="docutils literal notranslate"><span class="pre">pid</span> <span class="pre">=</span> <span class="pre">1</span></code>) is named <strong>init</strong>. It starts executing at the last stage of the boot process. Its <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task</span></code> is statically allocated (called <code class="docutils literal notranslate"><span class="pre">init_task</span></code>).</p>
<div class="section" id="creation">
<h3>Creation<a class="headerlink" href="#creation" title="Permalink to this headline">¶</a></h3>
<p>The operation of process initialization is twofold - first, <code class="docutils literal notranslate"><span class="pre">fork()</span></code> creates a child process with copied parent properties and data, and then <code class="docutils literal notranslate"><span class="pre">exec()</span></code> loads a new executable and starts executing it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Instead of actually copying the parent’s address space and other data, a Copy-On-Write methodology is used, meaning that until an actual write operation, the “copied” resources are actually shared between the parent and its child.</p>
</div>
<p>The callstack when executing <code class="docutils literal notranslate"><span class="pre">fork()</span></code> eventually looks like that:</p>
<blockquote>
<div><p>1. <code class="docutils literal notranslate"><span class="pre">fork</span> <span class="pre">()</span></code> 2. <code class="docutils literal notranslate"><span class="pre">clone</span> <span class="pre">()</span></code> 3. <code class="docutils literal notranslate"><span class="pre">do_fork</span> <span class="pre">()</span></code>
4. <code class="docutils literal notranslate"><span class="pre">copy_process</span> <span class="pre">()</span></code> – This function performs the majority of the work</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>It duplicates the descriptors of the parent (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span></code>, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">thread_info</span></code>)</p></li>
<li><p>Updates some of the values of these descriptors to initial or poison values</p></li>
<li><p>Sets the process to <code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code></p></li>
<li><p>Allocates a pid</p></li>
<li><p>Depending on the passed flag configuration the resources are either shared or cloned.</p></li>
</ol>
</div></blockquote>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As we mentioned earlier, threads and processes are not so different in kernelland in terms of representation. This is clearly seen here, <code class="docutils literal notranslate"><span class="pre">clone(SIGCHLD,</span> <span class="pre">0);</span></code> is called from “regular” <code class="docutils literal notranslate"><span class="pre">fork()</span></code>, whilst <code class="docutils literal notranslate"><span class="pre">clone(CLONE_VM,</span> <span class="pre">CLONE_FS,</span> <span class="pre">CLONE_FILES,</span> <span class="pre">CLONE_SIGHAND,</span> <span class="pre">0);</span></code> is called when creating a thread.</p>
</div>
<p>In the kernel, there exist a notion of solely kernel-executing threads, which <em>do not</em> context switch into userland. Furthermore, they do not have their own address space (their <code class="docutils literal notranslate"><span class="pre">mm</span></code> pointer equals <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). All of them are forked off the <code class="docutils literal notranslate"><span class="pre">kthreadd</span></code>. (The interface is defined in <code class="docutils literal notranslate"><span class="pre">&lt;linux/kthread.h&gt;</span></code>).</p>
</div>
<div class="section" id="termination">
<h3>Termination<a class="headerlink" href="#termination" title="Permalink to this headline">¶</a></h3>
<p>Process termination is handled mostly by the <code class="docutils literal notranslate"><span class="pre">do_exit()</span></code> function (<code class="docutils literal notranslate"><span class="pre">kernel/exit.c</span></code>).</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Sets flag in the <code class="docutils literal notranslate"><span class="pre">task_struct</span></code> of the process which denotes that the process is exiting.</p></li>
<li><p>Removes kernel timers associated with the process.</p></li>
<li><p>Releases the address space. If the cound of processes which use it equals 0, it is also destroyed.</p></li>
<li><p>Dequeue from IPC semaphores.</p></li>
<li><p>Decrements the usage count of objects related  to file descriptors and other file system data.</p></li>
<li><p>Stores a copy of the exit code.</p></li>
<li><p>Notifies the parent of the process’ untimely demise.</p></li>
<li><p>Calls <code class="docutils literal notranslate"><span class="pre">schedule()</span></code>, which performs a context switch. The process never gets scheduled again, and therefor it never returns from the <code class="docutils literal notranslate"><span class="pre">schedule()</span></code> call.</p></li>
</ol>
</div></blockquote>
<p>A problem arises when the parent exits before the child, the child will forever remain a zobie. The solution is to reparent either to another process from the same thread group, or to the <code class="docutils literal notranslate"><span class="pre">init</span></code> process itself.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>An opaque type is a type whose concrete structure is not exposed, enforcing information hiding.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="process-scheduling">
<h2>Process Scheduling<a class="headerlink" href="#process-scheduling" title="Permalink to this headline">¶</a></h2>
<p>The fundamental decision which the scheduler has to make is the following: Given a set of processes, which one should execute now?</p>
<p>Multitasking - the art of interleaving execution of multiple tasks, is based on either <em>preemptive</em> or <em>cooperative</em> multitasking scheme.</p>
<dl class="simple">
<dt>Preemptive multitasking</dt><dd><p>The scheduler has full control over which process executes and when it executes. It has the power to cease the execution of process A and to resume the execution of process B, and then to repeat this same action with it after some time. This involuntary suspencion is called preemption.
This mechanism is based on a value (usually referred to as <em>timeslice</em> or something along the lines), which represents the amount of time which the process has to execute. The timeslice may be preset or dynamically calculated.</p>
</dd>
<dt>Cooperative multitasking</dt><dd><p>Rather than having full control over the current process, the scheduler delegates these power to each and every process. Instead of being forced to “pause” (or rather - directly suspended), the process decides on its own when to <em>yield</em>, when to allow other processes to get some CPU time. The negative possibilities are apparent - a process may decide not to yield… ever.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the couple decades systems utilizing cooperative multitasking are not prevalent. For obvious reasons.</p>
</div>
<p>Before Linux 2.6.23, the scheduler had not been transformed since its original implementation. <strong>TODO: Add description of original scheduler</strong>. The transformation resulted in what is nowadays known as the O(1) scheduler. It improves on the limitations of the original scheduler, by introducing a constant-time algorithm for timeslice calculation, as well as adding per-processor run queues.</p>
<p>However, although the O(1) completety outperforms the previous scheduler in regular tasks, when it comes to interactive programs (ones which expect used input, i.e desktop applications), it was kind of bad. Therefoce a new concept turned up and it resulted in the <a class="reference external" href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely Fair Scheduler</a> which is currently being used.</p>
<div class="section" id="scheduler-policy">
<h3>Scheduler Policy<a class="headerlink" href="#scheduler-policy" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>These are the rules by which new processes are picked and ran. It has to satisfy two goals:</dt><dd><ol class="arabic simple">
<li><p>Low latency</p></li>
<li><p>High throughput</p></li>
</ol>
</dd>
</dl>
<p>Each process could be classfied in one the following two categories:</p>
<dl class="simple">
<dt>I/O Bound</dt><dd><p>Spend most of their time in submitting and waiting on I/O requests. Therefore, it is running (and runnable) for only short periods of time, because it has to block, while waiting for response. Example for I/O bound process is each and every GUI application ever.</p>
</dd>
</dl>
<p>or</p>
<dl class="simple">
<dt>CPU Bound</dt><dd><p>Spend most of their time executing instructions. Generally executed until preempted (do not block often). An example is the program ssh-keygen.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although most of the times processes are more of one type than the other, it could have characteristics of both.</p>
</div>
</div>
<div class="section" id="prioritizing">
<h3>Prioritizing<a class="headerlink" href="#prioritizing" title="Permalink to this headline">¶</a></h3>
<p>A common scheme for scheduling is based on the processes’ priority. Higher priority processes are scheduled first, followed by a round-robin walk-through of the low-priority (if they equal value, of couse). The higher priority value might denote either preference in scheduling or longer timeslices.</p>
<p>Linux implements two separate disjoint priority values - <code class="docutils literal notranslate"><span class="pre">nice</span></code> and <code class="docutils literal notranslate"><span class="pre">real-time</span> <span class="pre">priority</span></code>. The first one marks how nice a process is to others, or how willing it is to allow others to go first. It is a value in the range [-20; 20) and the higher the value, the lower the priority. The <code class="docutils literal notranslate"><span class="pre">real-time</span> <span class="pre">priority</span></code> on the other hand is a value in the range [0; 100); the higher the value, the higher the priority. Usually, real-time processes have bigger values.</p>
</div>
<div class="section" id="timeslices">
<h3>Timeslices<a class="headerlink" href="#timeslices" title="Permalink to this headline">¶</a></h3>
<p>The CFS caculates timeslices in a unique way - instead of assigning actual values (i.e 10ms), it gives each process a proportion of the CPU based on the priority. Therefore, <code class="docutils literal notranslate"><span class="pre">timeslice</span> <span class="pre">=</span> <span class="pre">f(load</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">system)</span></code>. Moreover, the resulting proportion is mapped with the nice value of the process, which acts as a weight to it. Rather then choosing which process to run based on its priority, the CFS makes this decision relative to the evaluted proportion, where smaller value, means higher chance of being picked.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Timeslice may also be called <em>quantum</em> or <em>CPU slice</em>.</p>
</div>
</div>
<div class="section" id="desired-results-of-cfs">
<h3>Desired Results of CFS<a class="headerlink" href="#desired-results-of-cfs" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at an example: two processes executing in the system. One is highly interactive, thus - I/O bound (P), whilst the other is entirely CPU bound (Q). Since, we would like P to run smoothly from the user-perspective it should have high respond time, meaning it - low latency. Adversly, since Q is much more time consuming than P, we would not take into account latency introduced by the scheduling policy, which means that P should be more prioritized.</p>
<p>In the beginning, the CFS should give each of the two processes 50% of the CPU. However, P waits wait more time than executing, meaning that Q gets more CPU time. Taking all of this into account it is clear that since P runs way less than Q, it should get prioritized when it needs to, when it is being used (remember, it is an interactive process). Therefore, the CFS gives each process a <strong>fair</strong> execution policy.</p>
<p>Several problems exist in the above-described scheme with which the CFS has to deal with:</p>
<dl class="simple">
<dt>Problem #1</dt><dd><p>If we try to map the nice value to a timeslice (or %), we end up with a problem. Let’s say that there are two processes - one with 0 nice and one with 20 nice. Let’s also say that 0 nice corresponds to a timeslice of 100ms. With this config, the scheduler will give the first process 100 out of 105 ms and 5ms to the second. However if two processes with 20 nice value exist, each of them would get 5ms. In reality this is 50% of the CPU, but this is inefficient since there should be a context switch each 5ms.</p>
</dd>
<dt>Problem #2</dt><dd><p>Two processes - 0 and 1 nice values. Let’s say that 0 nice corresponds to 100ms timeslice. This means that the first process gets 100ms and the second - 95ms, which is a 5% difference. If we change the nice-timeslice mapping, to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">nice</span> <span class="pre">-&gt;</span> <span class="pre">10ms</span></code>, the processes get 10ms and 5ms respectively, which is a 50% difference. This means that “nicing a process down” has very different effects depending on the mapping.</p>
</dd>
<dt>Problem #3</dt><dd><p>An ability to assign absolute timeslices is desired in kernel time. This is a metric based on the period of the timer tick.
<strong>TODO: Revisit after Ch. 11 and fill</strong></p>
</dd>
<dt>Problem #4:</dt><dd><p>Handling process after wake-up - we would to give a fresly woken up process a higher chance of being scheduled in order to improve interactiveness of I/O bound programs, but this might result in a unfair amount of CPU time.</p>
</dd>
<dt>Pseudo-solutions</dt><dd><ul class="simple">
<li><p>Geomtric nice values (instead of arithmetic)</p></li>
<li><p>Decoupled measurement mapping timeslices to timer ticks</p></li>
</ul>
</dd>
<dt>Actual problem</dt><dd><p>Assigning absolute timeslices yields a constant switching rate, but variable scheduling fairness.</p>
</dd>
</dl>
</div>
<div class="section" id="completely-fair-scheduling-algorithm">
<h3>Completely Fair Scheduling Algorithm<a class="headerlink" href="#completely-fair-scheduling-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Since Linux is kinda complex, it allows different scheduling algorithms to coexist and actually operate coherently. This is implemented via <em>sheduling classes</em>, where ach class reprents a different algorithm. Each of them is assigned a priority value that is used when the base scheduler chooses which concrete scheduler to perform its algorithm at a given time (higher priority means higher chance of being picked). Among all scheduler classes, the CFS is set as default (<code class="docutils literal notranslate"><span class="pre">SCHED_NORMAL</span></code> within the kernel).</p>
<dl class="simple">
<dt>Perfect Multitasking</dt><dd><p>Rather then running two processes each for 5ms while utilizing 100% of the CPU, in an ideal perfect multitasking CPU we run them for 10ms and each of them gets 50% of the CPU.</p>
</dd>
</dl>
<p>This model is impractictal since it does not take switching costs in account.</p>
<p>Firstly, the base proportion is calcaulted - <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">n</span></code> (where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the total # of processes). Following that, instead of <em>assigning</em> a timeslice to each process based on the nice value, CFS uses it to <em>weight</em> the proportion of CPU each process receives.</p>
<dl class="simple">
<dt>Targeted latency</dt><dd><p>Approximation of the “infinetely small” scheduling duration.</p>
</dd>
</dl>
<p>The actual timeslice is calculated according to the target latency - if two tasks with equal priority exist, each of them will execute for 10ms, if five tasks with equal priority exists, each of them will execute for 4 ms, etc.</p>
<dl class="simple">
<dt>Minimum granularity</dt><dd><p>The minimum amount of time a process may execute. (By default - 1ms).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With higher number of process, the timeslice each of them gets decreases. This means that with infinte # of process, each one of them will get &lt;something-close-to-0&gt; ms. Therefore, <em>minimum granularity</em> is defined as a bare-minumim for each process to execute. However, as the # of processes increases, the fairness of the scheduler drops.</p>
</div>
<dl class="simple">
<dt>Revisit Problem #2</dt><dd><p>With two processes (0 and 5 as nice values) and <code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">latency</span> <span class="pre">=</span> <span class="pre">20ms</span></code>, then they will get 15ms and 5ms timelices respectively. If, they have 10 and 15 as nice values, the timeslices are again 15ms and 5ms respectively.</p>
</dd>
</dl>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// include/linux/sched.h</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">struct</span> <span class="nc">sched_entity</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">        </span><span class="k">struct</span> <span class="nc">load_weight</span><span class="w">      </span><span class="n">load</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="k">struct</span> <span class="nc">rb_node</span><span class="w">          </span><span class="n">run_node</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">        </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">        </span><span class="n">group_node</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">            </span><span class="n">on_rq</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">exec_start</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">sum_exec_runtime</span><span class="p">;</span><span class="w"></span>
<span class="hll"><span class="linenos">11</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">vruntime</span><span class="p">;</span><span class="w"></span>
</span><span class="linenos">12</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">prev_sum_exec_runtime</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">last_wakeup</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">avg_overlap</span><span class="p">;</span><span class="w"></span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">nr_migrations</span><span class="p">;</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">start_runtime</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">avg_wakeup</span><span class="p">;</span><span class="w"></span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">        </span><span class="n">u64</span><span class="w">                     </span><span class="n">avg_running</span><span class="p">;</span><span class="w"></span>
<span class="linenos">23</span><span class="w">        </span><span class="p">[...]</span><span class="w"></span>
<span class="linenos">24</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<dl class="simple">
<dt>Virtual runtime - <code class="docutils literal notranslate"><span class="pre">vruntime</span></code></dt><dd><p>The actual time that the process spent running (weighted) in nanoseconds. This is used to approximate the “perfect multitasking CPU”. In the ideal case it would not be useful, since all of the processes would have gotten the same amount of the CPU share. There is some accounting needed in order to keep it up-to-date. It is implemented in the <code class="docutils literal notranslate"><span class="pre">update_curr()</span></code> function.</p>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// kernel/sched_fair.c</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">update_curr</span><span class="p">(</span><span class="k">struct</span> <span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 4</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">     </span><span class="k">struct</span> <span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">     </span><span class="n">u64</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">delta_exec</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">))</span><span class="w"></span>
<span class="linenos">10</span><span class="w">             </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">     </span><span class="cm">/*</span>
<span class="linenos">13</span><span class="cm">      * Get the amount of time the current task was running</span>
<span class="linenos">14</span><span class="cm">      * since the last time we changed load (this cannot</span>
<span class="linenos">15</span><span class="cm">      * overflow on 32 bits):</span>
<span class="linenos">16</span><span class="cm">      */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="n">delta_exec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">delta_exec</span><span class="p">)</span><span class="w"></span>
<span class="linenos">19</span><span class="w">             </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">     </span><span class="n">__update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">delta_exec</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span><span class="w">     </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">25</span><span class="w">             </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">curtask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_of</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span><span class="w"></span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">             </span><span class="n">trace_sched_stat_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span><span class="w"> </span><span class="n">delta_exec</span><span class="p">,</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="w">             </span><span class="n">cpuacct_charge</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span><span class="w"> </span><span class="n">delta_exec</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="w">             </span><span class="n">account_group_exec_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span><span class="w"> </span><span class="n">delta_exec</span><span class="p">);</span><span class="w"></span>
<span class="linenos">30</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">31</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As far as I see, there has not been a huge change until now (5.14.7). The only notable difference is that the <code class="docutils literal notranslate"><span class="pre">__update_curr()</span></code> function has been removed and its body has been incorporated directly inside <code class="docutils literal notranslate"><span class="pre">update_curr</span></code>.</p>
</div>
<p>The above function is called periodically both when a process becomes eligible for running and when it gets blocked. Therefore, the <code class="docutils literal notranslate"><span class="pre">vruntime</span></code> is accurate.
Therefore, it directly maps the fairness with which the process has been treated, the algorithm for picking the next process to schedule becomes - choose the process with lowest <code class="docutils literal notranslate"><span class="pre">vruntime</span></code> value. Furthermore, the list of runnable processes is organised in a <code class="docutils literal notranslate"><span class="pre">rbtree</span></code> in order to efficiently locate the one with minumim <code class="docutils literal notranslate"><span class="pre">vruntime</span></code> value, so the actual “pick-next-process” operation becomes “go left until nothing is left” :). If has not been simplified enough, a tree walk isn’t even required since the leftmost element is cached in the CPU runqueue (see <code class="docutils literal notranslate"><span class="pre">__pick_next_entity()</span></code>).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// kernel/sched_fair.c</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">__pick_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 4</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="k">struct</span> <span class="nc">rb_node</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rb_leftmost</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rb_entry</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sched_entity</span><span class="p">,</span><span class="w"> </span><span class="n">run_node</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned from <code class="docutils literal notranslate"><span class="pre">__pick_next_entity()</span></code>, there are no schedulable processes and the idle process is ran.</p>
</div>
<p>The functions which add processes in the red-black tree are named <code class="docutils literal notranslate"><span class="pre">enqueue_entity()</span></code> - updates statistics, and <code class="docutils literal notranslate"><span class="pre">__enqueue_entity()</span></code> - actual tree modification. This is the same function which caches the leftmost element. It gets executed when a process gets runnable. Logically, <code class="docutils literal notranslate"><span class="pre">dequeue_entity()</span></code> and <code class="docutils literal notranslate"><span class="pre">__dequeue_entity()</span></code> are those who handle the entity removing logic, when a process blocks or terminates.</p>
<p>The entry point of the scheduler is <code class="docutils literal notranslate"><span class="pre">schedule()</span></code> function. This is the abstract high-level routine which everybody calls when they need to “do something with the scheduler”. The most interesting thing that happens is the <code class="docutils literal notranslate"><span class="pre">pick_next_task()</span></code> function call which selects the next scheduler class to operate.</p>
</div>
<div class="section" id="waiting-and-waking-up">
<h3>Waiting and Waking-Up<a class="headerlink" href="#waiting-and-waking-up" title="Permalink to this headline">¶</a></h3>
<p>Processor blocking is implemented the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The task marks itself as sleeping</p></li>
<li><p>Puts itself in a wait-queue</p></li>
<li><p>Removes itself from the red-black tree</p></li>
<li><p>Calls <code class="docutils literal notranslate"><span class="pre">schedule()</span></code> to select new process</p></li>
</ol>
</div></blockquote>
<p>Waking-up is the opposite - runnable, removed from wait-queue and added to the red-black.</p>
<p>Waiting in the kernel is usually done in the following way:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// q is the wait-queue, we wish to sleep on</span>
<span class="linenos"> 2</span><span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">add_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// condition is the event that we are waiting for</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">                </span><span class="c1">// handle</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">        </span><span class="n">schedule</span><span class="p">();</span><span class="w"></span>
<span class="linenos">12</span><span class="p">}</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>Instantiate an empty wait queue entry called <code class="docutils literal notranslate"><span class="pre">wait</span></code>.</p></li>
<li><p>Add entry to wait queue (<code class="docutils literal notranslate"><span class="pre">wait</span> <span class="pre">-&gt;</span> <span class="pre">q</span></code>).</p></li>
<li><p>Change process state to <code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRIPTIBLE</span></code>. Moreover, it may add the entry to the wait queue again if needed.</p></li>
<li><p>Catch <em>spurious wake ups</em> (one which was not caused by the occurance of the specified event).</p></li>
<li><p>If the condition is still not correct, <code class="docutils literal notranslate"><span class="pre">schedule()</span></code> is called. Then <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">3</span></code>.</p></li>
<li><p>Else, the process’ state is switched to <code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> and it’s removed from the wait queue.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Usually real kernel code using this mechanism is not that simple. There might be (and almost always are) additional resources that require be taken care of.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Just because a task is awakened does not mean that the event for which the task is waiting has occured; <strong>Sleeping should always be handled in a loop that ensures that the condition for which the process is waiting has actually occurred</strong>.</p>
</div>
<img alt="_images/scheduler_states_relationship.png" src="_images/scheduler_states_relationship.png" />
</div>
<div class="section" id="preemption-and-context-switching">
<h3>Preemption and Context Switching<a class="headerlink" href="#preemption-and-context-switching" title="Permalink to this headline">¶</a></h3>
<p>Handled by the <code class="docutils literal notranslate"><span class="pre">context_switch()</span></code> function, which</p>
<ol class="arabic simple">
<li><p>Calls <code class="docutils literal notranslate"><span class="pre">switch_mm()</span></code> - Swaps memory mapping of processes</p></li>
<li><p>Calls <code class="docutils literal notranslate"><span class="pre">switch_to()</span></code> - Changes register values and other arch-specific states</p></li>
</ol>
<p>Since the actual scheduling policy has to be invoked regularaly and not just manually by calling <code class="docutils literal notranslate"><span class="pre">schedule()</span></code>, the actual mechanism is by marking a process as “to-be-preempted” - the kernel sets a <code class="docutils literal notranslate"><span class="pre">need_resched</span></code> flag on it (Actually this value resides inside the <code class="docutils literal notranslate"><span class="pre">thread_info</span></code> struct). This is done by the <code class="docutils literal notranslate"><span class="pre">scheduler_tick()</span></code> when the process has be to preempted and by <code class="docutils literal notranslate"><span class="pre">try_to_wake_up()</span></code> when a higher priority process needs to run. Some utility functions …</p>
<table class="table">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">set_tsk_need_resched()</span></code></p></td>
<td><p>Sets flag</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">clear_tsk_need_resched()</span></code></p></td>
<td><p>Clears flag</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">need_resched()</span></code></p></td>
<td><p>Checks flag value</p></td>
</tr>
</tbody>
</table>
<p>User space preemption occurs when returning to userland either from an interrupt or from a syscall.
The Linux kernel is preemptive. This means that the kernel may preempt itself as long as its state allows it to do so. How do we decide whether it is safe or not? Locks. They are used as zoning markers. If no lock is being held, than the current piece of code being executed is fully reentrant.</p>
<p>This is implemented by a per-process <code class="docutils literal notranslate"><span class="pre">preempt_count</span></code> stored in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">thread_info</span></code>. Each time the process acquires a lock, the value is incremented, and each time a lock is released - decremented. This makes sure that when the value equals 0, the kernel is allowed to preempt the current kernel process.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>From time to time, there might be the need to disable kernel preemption.</p>
</div>
</div>
<div class="section" id="real-time-scheduling-policies">
<h3>Real-Time Scheduling Policies<a class="headerlink" href="#real-time-scheduling-policies" title="Permalink to this headline">¶</a></h3>
<p>Other than <code class="docutils literal notranslate"><span class="pre">SCHED_NORMAL</span></code>, the scheduling classes include <code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code> and <code class="docutils literal notranslate"><span class="pre">SCHED_RR</span></code>. <code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code> always operates before <code class="docutils literal notranslate"><span class="pre">SCHED_NORMAL</span></code> and does not stop until the task is runnable. Furthermore, it does not utilize timeslices and does not impose time limits. <code class="docutils literal notranslate"><span class="pre">SCHED_RR</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code> with the single exception that it actually has execution time limits.</p>
</div>
</div>
<div class="section" id="system-calls">
<h2>System Calls<a class="headerlink" href="#system-calls" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>“Provide mechanism, not policy”</strong></div>
<div class="line"><br /></div>
</div>
<p>Syscalls are the interface for the userland processes provided by the kernel.</p>
<p>The purposes of syscalls are handful. The majority of them are concerned with abstracting hardware resource, which on its own has a couple of benefits/purposes</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Security and stability</p></li>
<li><p>Allows the kernel to implement virtualization subsystems - multitasking, VM, etc.</p></li>
<li><p>Allows user processes to not care about internals</p></li>
</ol>
</div></blockquote>
<img alt="_images/printf_to_write.png" src="_images/printf_to_write.png" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">asmlinkage</span></code> modifier notifies the compiler to look for the actual argumets only on the stack. Used with all syscalls.</p>
</div>
<p>First, each syscall is implemented inside the kernel as <code class="docutils literal notranslate"><span class="pre">sys_{name}</span></code>. Each syscall is assigned what is known as a <em>syscall number</em>. The way that userland processes use to notify the kernel that they would like some kernel code to execute is by making a software interrupt (<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">$0x80</span></code>). It directly triggers the execution of the system call handler - <code class="docutils literal notranslate"><span class="pre">system_call()</span></code> (defined in <code class="docutils literal notranslate"><span class="pre">arch/include/asm/entry_64.S</span></code>). However, in order to execute the syscall, the kernel is also required to know the syscall number. In x86 this is passed through the <code class="docutils literal notranslate"><span class="pre">%eax</span></code> register. After the kernel traps, it simply maps the number to the corresponding syscall and is ready to execute it. Additionally, any arguments passed to the syscall are also transferred using registers. If there number exceeds the limit of 5, a pointer to the userland location where they are stored is passed instead. Return value is put into <code class="docutils literal notranslate"><span class="pre">%eax</span></code> as well.</p>
<p>Some of the problems related to syscalls are the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Aging and Scalability - Once the syscall is implemented and other applications depend on it, there is no going back. Will this API stand the toll of time?</p></li>
<li><p>Parameters - The syscall is kernel code - it has super-powers. How sure are you that <strong>any</strong> parameters passed to it will not damage or corrupt the system?</p></li>
<li><p>Access Rights - Does the userland process have access to what it asks for?</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Kernel code should never blindly follow userland pointers! If a copy has to be made, always use <code class="docutils literal notranslate"><span class="pre">copy_to_user()</span></code> or <code class="docutils literal notranslate"><span class="pre">copy_from_user()</span></code> depending on the situation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">&lt;linux/capability.h&gt;</span></code> and its macro <code class="docutils literal notranslate"><span class="pre">capable()</span></code> to check whether a userland process has certain capabilities.</p>
</div>
<p>System calls are “registered” in libc by using macros defined in the kernel. If we are to register our new syscall - “myfun”, it would look similar to that.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// kernel/sys.c</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">myfun</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">);</span><span class="w"></span>

<span class="c1">// lib.h</span>

<span class="cp">#define __NR_myfun   283</span>
<span class="n">__syscall3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">myfun</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"></span>

<span class="c1">// lib.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;lib.h&quot;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">myfun_rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myfun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hihi&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="kernel-data-structures">
<h2>Kernel Data Structures<a class="headerlink" href="#kernel-data-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linked-lists">
<h3>Linked Lists<a class="headerlink" href="#linked-lists" title="Permalink to this headline">¶</a></h3>
<p>The kernel provides an intrinsic circular doubly-linked list implemented. It is defined in <code class="docutils literal notranslate"><span class="pre">&lt;linux/list.h&gt;</span></code> and provides a lot of functionlaities, including</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_add()</span> <span class="pre">list_add_tail()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_del()</span> <span class="pre">list_del_init()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_move()</span> <span class="pre">list_move_tail()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_splice()</span> <span class="pre">list_splice_init()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_entry()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_empty()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_for_each()</span> <span class="pre">list_for_each_entry()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_reverse()</span> <span class="pre">list_for_each_entry_safe()</span></code></div>
</div>
</div></blockquote>
</div>
<div class="section" id="queues">
<h3>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h3>
<p>The kernel provides a queue implementation, defined in <code class="docutils literal notranslate"><span class="pre">&lt;linux/kfifo.h&gt;</span></code>. Basic operations are
The size of the queue is required to be a power of 2.</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">kfifo_alloc()</span> <span class="pre">kfifo_init()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">kfifo_in()</span> <span class="pre">kfifo_out()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">kfifo_out_peek()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">kfifo_size()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">kfifo_destroy()</span> <span class="pre">kfifo_reset()</span></code></div>
</div>
</div></blockquote>
</div>
<div class="section" id="maps">
<h3>Maps<a class="headerlink" href="#maps" title="Permalink to this headline">¶</a></h3>
<p>Not a general purpose map - is specifically designed to map userspace UID’s to pointers. Additionally, it may also generate this UID. The struct is called <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span></code>.</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">idr_init()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">idr_pre_get()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">idr_find()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">idr_remove()</span></code></div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span></code> functions return 1 on success and 0 on error!</p>
</div>
</div>
<div class="section" id="trees">
<h3>Trees<a class="headerlink" href="#trees" title="Permalink to this headline">¶</a></h3>
<p>The kernel implementation of a binary tree is the red-black tree. In order for a binary tree to be considered red-black it has to satisfy the following properties</p>
<dl class="simple">
<dt>Black height of a red-black tree</dt><dd><p>The number of all black nodes in a given path</p>
<ol class="arabic simple">
<li><p>All nodes must be either red, or black</p></li>
<li><p>All leaf nodes are black</p></li>
<li><p>None of the leaf nodes store any data</p></li>
<li><p>Each internal nodes have two children</p></li>
<li><p>A red parent has two black children</p></li>
<li><p>The black height is equal for every subtree</p></li>
</ol>
</dd>
</dl>
<p>Red-black trees are considered “approximately-” or “semi-” balanced, since they do not corresponds to the definition. However, they still guarantee <span class="math notranslate nohighlight">\(O(\log_{2})\)</span> complexity.</p>
<blockquote>
<div><div class="line-block">
<div class="line">Binary tree is balanced if for each node that it holds, the number of nodes in the left subtree and the number of nodes in the right subtree differ by at most 1.</div>
</div>
</div></blockquote>
<img alt="_images/rbtree.png" class="align-center" src="_images/rbtree.png" />
<p>The kernel red-black tree API resides in <code class="docutils literal notranslate"><span class="pre">&lt;linux/rbtree.h&gt;</span></code>. The interesting thing about it is that it does not provide an actual insert or search operation, in order to omit the usage of callbacks and comparison functions. This is what they should look like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/rbtree.h&gt;</span><span class="cp"></span>

<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="nf">rbtree_search</span><span class="p">(</span><span class="n">V</span><span class="w"> </span><span class="n">desired_inner_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">rb_node</span><span class="w"> </span><span class="o">*</span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...];</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">nod</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb_entry</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="p">[...]</span><span class="w"> </span><span class="cm">/* container rbtree */</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">inner_value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">desired_inner_value</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nod</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">inner_value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">desired_inner_value</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nod</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">else</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">rbtree_insert</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">entry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">rb_node</span><span class="w"> </span><span class="o">**</span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[...]</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">rb_node</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="o">*</span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nod</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">nod</span><span class="p">;</span><span class="w"></span>
<span class="w">               </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">nod</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="p">[...]</span><span class="w"> </span><span class="cm">/* container rbtree */</span><span class="p">);</span><span class="w"></span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">inner</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">inner</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span><span class="w"></span>
<span class="w">               </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">inner</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">inner</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span><span class="w"></span>
<span class="w">               </span><span class="k">else</span><span class="w"></span>
<span class="w">                       </span><span class="k">return</span><span class="w"> </span><span class="n">ERROR_ALREADY_APPEARS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">rb_link_node</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">);</span><span class="w">             </span><span class="c1">// Actual insert modification</span>
<span class="w">        </span><span class="n">rb_insert_color</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[...]);</span><span class="w">                </span><span class="c1">// Rebalancing</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interrupt-handling">
<h2>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h2>
<p>Interrupts replace polling, which incurs overhead. Rather than the CPU checking all hardware devices <em>once in a while</em>, each time a device needs “help” it notifies the CPU using an interrupt. Than the CPU signals the OS about the interrupt, which on its side starts executing the interrupt handler associated with the specific interrupt. Each interrupt has a unique number associated with it, in order to simplify the task of identifying the interrupt and its origin. They are often called IRQ lines. These interrupts are produced <em>asynchronously</em> by “external” hardware. There exist another type of interrups, often called exceptions, <em>synchrounous interrupts</em>, which are produced by the CPU. They are produced during program execution due to an error - division by 0, trap, page falut, etc.</p>
<p>The function that the kernel executes in order to handle an interrupt is usually abbreviated as <em>ISR</em> (= Interrupt Service Routine). It is part of the device driver. They run in a special <em>interrupt context</em> and it is unable to block, thus guarantying that the ISR is atomic. Since an interrupt may happen at any given time, it is important that the code inside the ISR executes quickly in order to return to other kernel operations. However, it is not uncommon that the ISR actually has to perform a lot of work (e.g network drivers).</p>
<p>Therefore, the interrupt processing is split into two</p>
<dl class="simple">
<dt>Top and bottom halves</dt><dd><p>In the “top” - work is performed immediately upon receive, whereas the “bottom” is ran in a more convenient time. The top-half algorithm is implemented via the interrupt handler.</p>
</dd>
</dl>
<p>Firstly, an interrupt handler needs to be registered. This is done with the <code class="docutils literal notranslate"><span class="pre">request_irq()</span></code> function (<code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code>). One of its parameters is a callback to the handler implementation, which is of type <code class="docutils literal notranslate"><span class="pre">irq_handler_t</span></code>, defined as</p>
<blockquote>
<div><p><code class="code c docutils literal notranslate"><span class="keyword"><span class="pre">typedef</span></span><span class="whitespace"> </span><span class="name"><span class="pre">irqreturn_t</span></span><span class="whitespace"> </span><span class="punctuation"><span class="pre">(</span></span><span class="operator"><span class="pre">*</span></span><span class="name"><span class="pre">irq_handler_t</span></span><span class="punctuation"><span class="pre">)(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">,</span></span><span class="whitespace"> </span><span class="keyword type"><span class="pre">void</span></span><span class="whitespace"> </span><span class="operator"><span class="pre">*</span></span><span class="punctuation"><span class="pre">)</span></span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">irqreturn_t</span></code> is actually <code class="docutils literal notranslate"><span class="pre">int</span></code>, but the typedef is required in order to preserve backwards compatibility.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">request_irq()</span></code> may <em>block</em>. Therefore, it <strong>should not</strong> be called from an interrupt handler (it executes in atomic context).</p>
</div>
<p>At the end, handlers are freed using <code class="docutils literal notranslate"><span class="pre">free_irq()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Interrupt handlers are not required to bee reentrant, since they execute in atomic context (as said before).</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Interrupts <strong>interrupt</strong> processes. They have to be quick and simple. They have to not call any blocking functions and should not busy wait. They hvae to not call functions which may leave the interrupt handlers, before being fully executed, since the scheduler cannot go back to the previous position in the irq handler. Moreover, during interrupts there is an per-CPU <em>interrupt stack</em> of 1 memory page.</p>
</div>
<img alt="_images/irq_handling_chain.png" class="align-center" src="_images/irq_handling_chain.png" />
<p>Interrupts for the current CPU may be disabled and enabled using <code class="docutils literal notranslate"><span class="pre">local_irq_disable()</span></code> and <code class="docutils literal notranslate"><span class="pre">local_irq_enable()</span></code>, but this is not very useful, since by using this pait of utilities, there is no guarantee that in interrupts were enabled in the beginning. Therefore, more common are <code class="docutils literal notranslate"><span class="pre">local_irq_save()</span></code> and <code class="docutils literal notranslate"><span class="pre">local_irq_restore()</span></code> which carefully handle the irq flags. Additionally, specific irq lines may be disabled and enabled - <code class="docutils literal notranslate"><span class="pre">disable_irq()</span></code>, <code class="docutils literal notranslate"><span class="pre">enable_irq()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">disabled_irq()</span></code> is called two times, then in order to re-enable them, <code class="docutils literal notranslate"><span class="pre">enable_irq()</span></code> has to be called twice as well.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If the work is</p>
<blockquote>
<div><ul class="simple">
<li><p>time sensitive or</p></li>
<li><p>related to the hardware or</p></li>
<li><p>required to execute in atomic context, without being interrupted</p></li>
</ul>
</div></blockquote>
<p>put it inside the interrupt handler. For everything else - the bottom half will do. The fundamental question is “What <em>must</em> be in the top-half and what <em>can</em> be in the bottom half?”.</p>
</div>
<div class="section" id="bottom-halves">
<h3>Bottom halves<a class="headerlink" href="#bottom-halves" title="Permalink to this headline">¶</a></h3>
<p>There are multiple of mechanisms used for deferring work from the interrupt handlers.</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">softirq</span></code></dt><dd><p>Used for the most time-critical bottom halves. Usually involve a lot of careful and fine-grained locking. Allocated, prioritized and assigned statically. Then the softirq is <em>raised</em> at runtime, usually in the top half. All of the softirqs are checked and handled by <code class="docutils literal notranslate"><span class="pre">do_softirq()</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tasklet</span></code></dt><dd><p>Basically high-level softirqs - do not require difficult locking policies, but have less priority. The main difference compared to softirqs is that tasklets run on only CPU at a given time, whilst with there might be the case of two of the <em>same</em> softirqs executing concurrently on separate CPUs.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">do_softirq</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">u32</span><span class="w"> </span><span class="n">pending</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">pending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_softirq_pending</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pending</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">struct</span> <span class="nc">softirq_action</span><span class="w"> </span><span class="o">*</span><span class="n">h</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="cm">/* reset the pending bitmask */</span><span class="w"></span>
<span class="w">                </span><span class="n">set_softirq_pending</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">softirq_vec</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pending</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">h</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">(</span><span class="n">h</span><span class="p">);</span><span class="w"></span>
<span class="w">                        </span><span class="n">h</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">pending</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pending</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Almost always tasklets are good enough for the job and only in extremeley rare cases softirqs are required.</p>
<p>An analog to raised softirq is the <em>scheduled tasklet</em>. This is implemented in <code class="docutils literal notranslate"><span class="pre">tasklet_schedule()</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Obviously pseudo-code :)</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">tasklet_schedule</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cas</span><span class="p">(</span><span class="n">tasklet</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">TASKLET_SCHED</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">local_irq_save</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">list_add</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">tasklet_vec</span><span class="p">,</span><span class="w"> </span><span class="n">tasklet</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">raise_softirq_with_disabledirq</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">local_irq_restore</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The real operation is handled in the <code class="docutils literal notranslate"><span class="pre">tasklet_action()</span></code> function. The following is snippet illustrates its jobs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">tasklet_action</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">local_irq_disable</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">tasklet</span><span class="w"> </span><span class="o">*</span><span class="n">tasklet_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_extract</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">tasklet_vec</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">local_irq_enable</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tasklet_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tasklet_list</span><span class="o">-&gt;</span><span class="n">acquire</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="p">(</span><span class="n">tasklet_list</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="c1">// is it disabled?</span>
<span class="w">                                </span><span class="k">goto</span><span class="w"> </span><span class="n">release</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">tasklet_list</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TASKLET_RUN</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">tasklet_list</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">();</span><span class="w"></span>
<span class="w">                        </span><span class="n">tasklet_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tasklet_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="nl">release</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">tasklet</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are two types of tasklets - <code class="docutils literal notranslate"><span class="pre">TASKLET_SOFTIRQ</span></code> and <code class="docutils literal notranslate"><span class="pre">HI_SOFTIRQ</span></code>. This effectively means that without being statically initialized, all takslets are <em>multiplexed</em> of these two softirqs. The <code class="docutils literal notranslate"><span class="pre">HI_</span></code> one has higher priority (ch. <code class="docutils literal notranslate"><span class="pre">include/interrupt.h</span></code> for the full priority enum).</p>
</div>
<p>There exist a per-CPU <em>ksoftirqd</em> thread which supports the handling of softirqs (thus tasklets as well). They are introduced as a compromise between two bad suggestions of handling re-raised softirqs</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt>Before returning from <code class="docutils literal notranslate"><span class="pre">do_softirq()</span></code> perform a check whether any of them have been raised again and execute them if that’s the case.</dt><dd><ul class="simple">
<li><p>However, this is highly inefficient since this leaves the userland processes in a bad position - they will have a lot of latency and only interrupts and softirqs will ever execute.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Do not treat re-raised softirqs specially - just wait until the next <code class="docutils literal notranslate"><span class="pre">do_softirq</span></code> call.</dt><dd><ul class="simple">
<li><p>However, this ultimately means that in most cases re-raised softirqs will be handled way to late since this will probably be on the next irq.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>Taking all this into account, the kerneldevs add per-CPU kernel thread which looks after the softirqs but does not neglect the userland processes by setting the ksoftirqd’s nice value to 19.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ksoftirq_main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">softirq_pending</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span><span class="w"></span>
<span class="w">                        </span><span class="n">schedule</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">softirq_pending</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">do_softirq</span><span class="p">();</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">need_resched</span><span class="p">())</span><span class="w"></span>
<span class="w">                                </span><span class="n">schedule</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="work-queues">
<h3>Work Queues<a class="headerlink" href="#work-queues" title="Permalink to this headline">¶</a></h3>
<p>Different approach to the problem of deferring work.</p>
<ul class="simple">
<li><p>Do not execute in atomic context - may block</p></li>
<li><p>Into threads, not processes</p></li>
<li><p>Used in preferance to kernel threads</p></li>
<li><p>Usually called worker threads - <code class="docutils literal notranslate"><span class="pre">events/n</span></code>; per-CPU</p></li>
</ul>
<a class="reference internal image-reference" href="_images/workqs_impl.png"><img alt="_images/workqs_impl.png" src="_images/workqs_impl.png" style="width: 526.4px; height: 376.0px;" /></a>
</div>
</div>
<div class="section" id="kernel-synchronisation">
<h2>Kernel Synchronisation<a class="headerlink" href="#kernel-synchronisation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general">
<h3>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>Critical section</dt><dd><p>Code areas which access shared data. <strong>Unsafe.</strong></p>
</dd>
</dl>
<p>⇒  Atomics, otherwise <em>race condition</em> occurs.</p>
<p>Causes of concurrency in the kernel world</p>
<blockquote>
<div><ul class="simple">
<li><p>Interrupts, taskelts, softirqs</p></li>
<li><p>Sleeping and synchronisation with userland</p></li>
<li><p>SMP</p></li>
<li><p>Preemption</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="primitives">
<h3>Primitives<a class="headerlink" href="#primitives" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Atomic integer - <code class="code c docutils literal notranslate"><span class="name"><span class="pre">atomic_t</span></span></code> (32-bit) and <code class="code c docutils literal notranslate"><span class="name"><span class="pre">atomic64_t</span></span></code></dt><dd><ul class="simple">
<li><p>Instruction level sync primitives are used.</p></li>
<li><p>Many operations are supported, e.g <code class="docutils literal notranslate"><span class="pre">atomic_set()</span></code>, <code class="docutils literal notranslate"><span class="pre">atomic_get()</span></code>, <code class="docutils literal notranslate"><span class="pre">atomic_inc()</span></code>. Notably, there exist a couple which perform multiple actions <code class="docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code>, <code class="docutils literal notranslate"><span class="pre">atomic_inc_and_test()</span></code>, etc.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On most architectures a single word read is atomic. Thus, the <code class="docutils literal notranslate"><span class="pre">atomic_read()</span></code> has no additional complexities then just returning the value.</p>
</div>
<ol class="arabic" start="2">
<li><p>Atomic bitwise operations</p>
<blockquote>
<div><ul class="simple">
<li><p>Modifies bit values on opaque pointers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">test_and_set_bit()</span></code>, <code class="docutils literal notranslate"><span class="pre">get_bit()</span></code>, etc.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Non-atomic bit operation? Consider the case when a set, a following clear instruction are issued. At the end the bit will be 0, but there is no guarantee that it has ever been 1. This is the data race here.</p>
</div>
<ol class="arabic simple" start="3">
<li><dl class="simple">
<dt>Spin Locks</dt><dd><ul class="simple">
<li><p>Only one thread of execution at a time holds the spin lock.</p></li>
<li><p>If another tries to acquire it while the spin lock is contended, the thread <em>spins</em></p></li>
<li><p>Architecture specific. Arch-dependant code is in <code class="docutils literal notranslate"><span class="pre">asm/spinlock.h</span></code>, while the kernel API resides in <code class="docutils literal notranslate"><span class="pre">linux/spinlock.h</span></code>.</p></li>
<li><p>If the kernel is configured to not use preemption or the arch is not SMP, then spinlocks are compiled away completely.</p></li>
<li><p>Support “regular” API :). No surprises there.</p></li>
<li><p>Usually when working with spinlock, the code has to be cautious of bottom-halves, more specifically - whether there is shared data between the current thread of execution and bottom-halves. Thus, there is a function which stops bottom-halves while the spinlock is held, and another which does the opposite.</p></li>
<li><p>Reader-writer spinlock - <code class="docutils literal notranslate"><span class="pre">rwlock_t</span></code>. Analogous to spin lock, <strong>with the exception</strong> of separate reader and writer lock/unlock, etc.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
<a class="reference internal image-reference" href="_images/spinlock_api.png"><img alt="_images/spinlock_api.png" class="align-center" src="_images/spinlock_api.png" style="width: 569.0px; height: 246.5px;" /></a>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><strong>Rule of tumb</strong> Lock data and not code!</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Linux’ spin locks are not recursive - if a thread holding the spin lock, acquires it again, it is automatically in a deadlock.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Spin locks do not sleep - they busy wait. Thus, they might be used in atomic contexts (e.g interrupt handlers).</p>
</div>
<ol class="arabic" start="4">
<li><dl>
<dt>Semaphores</dt><dd><ul>
<li><p>Sleeping locks</p></li>
<li><p>Well-suited for long-held locks</p></li>
<li><p>Only for process context</p></li>
<li><p>Multiple semaphore “holders”</p>
<blockquote>
<div><ul>
<li><p>1 holder: either mutex or binary semaphore (depending on the usecase)</p></li>
<li><p>&gt;= 2 holders: counting semaphore</p>
<blockquote>
<div><ul class="simple">
<li><p>Enforce limits, but not mutual exclusion</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Two primary operations - <em>Proberen</em> (test) and <em>Verhogen</em> (increment)</p>
<blockquote>
<div><ul class="simple">
<li><p>The former decrements and acquries the semaphore, whereas</p></li>
<li><p>the latter increments and releases the semaphore</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">semaphore</span></code>; <code class="docutils literal notranslate"><span class="pre">sema_init()</span></code>, <code class="docutils literal notranslate"><span class="pre">down_interruptible()</span></code>, <code class="docutils literal notranslate"><span class="pre">up()</span></code>, <code class="docutils literal notranslate"><span class="pre">init_MUTEX()</span></code>, etc.</p></li>
<li><p>Also reader-writer semaphore - <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rw_semaphore</span></code></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Mutex</dt><dd><ul class="simple">
<li><p>Although, semaphores provide similar capabilities, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span></code> has simpler API and better performance.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><strong>Rule of tumb</strong> Prefer <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span></code> over <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">semaphore</span></code> (even with count limit 1).</p>
</div>
<a class="reference internal image-reference" href="_images/mutex_api.png"><img alt="_images/mutex_api.png" class="align-center" src="_images/mutex_api.png" style="width: 573.0px; height: 120.0px;" /></a>
<ol class="arabic" start="6">
<li><dl class="simple">
<dt>Completion Variable</dt><dd><ul class="simple">
<li><p>Conceptually similar to semaphores. Thread A signals thread B when an operation <em>completes</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span></code>; <code class="docutils literal notranslate"><span class="pre">init_completion()</span></code>, <code class="docutils literal notranslate"><span class="pre">wait_for_completion()</span></code>, <code class="docutils literal notranslate"><span class="pre">complete()</span></code></p></li>
<li><p>Check “sched.c” and “fork.c” for examples.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The Big Kernel Lock</p>
<blockquote>
<div><ul>
<li><p>Global spin lock. Yes… The idea was to ease the transition to fine-grained locking during the transition to SMP.</p></li>
<li><p>Peculiarities of the BKL</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>You can sleep while holding it.</p></li>
<li><p>Recursive lock.</p></li>
<li><p>Only in process context.</p></li>
</ol>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><dl class="simple">
<dt>Sequential Locks</dt><dd><ul class="simple">
<li><p>Used for accessing shared data.</p></li>
<li><p>On each write the sequence number is incremented (atomically). On each read the sequence number is checked before and after the operation. If they mismatch, then the read data is corrupted.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>Barriers</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">rmb()</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Read barrier. No reorders of <em>load()</em> operations pass the <em>barrier</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmb()</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Write barrier. No reorders of <em>store()</em> operations pass the <em>barrier</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mb()</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Read &amp; Write barrier</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">read_barrier_depends()</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Only for subsequent loads on which this depends.</p></li>
<li><p>Much quicker than <code class="docutils literal notranslate"><span class="pre">rmb()</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<div class="section" id="timers-and-time-management">
<h2>Timers and Time Management<a class="headerlink" href="#timers-and-time-management" title="Permalink to this headline">¶</a></h2>
<p>Real-Time Clock (RTC)</p>
<blockquote>
<div><p>Chip which counts without stopping. Has additional battery in order to keep going while the machine is off.</p>
</div></blockquote>
<p>System Timer</p>
<blockquote>
<div><p>Chip which interrupts the motherboard each <em>HZ</em> hertz</p>
</div></blockquote>
<p>Jiffy (pl. Jiffies)</p>
<blockquote>
<div><p>The kernel notion of time. The number of ticks from the system timer since boot.</p>
</div></blockquote>
<p>Timers</p>
<blockquote>
<div><p>Means for delaying work. Marks certain work to be executed after some time has passed (cannot guarantee that it is exactly precise, but only that is after at least the-given-period time).</p>
</div></blockquote>
<p>Additionally work may be delayed using <code class="docutils literal notranslate"><span class="pre">schedule_timeout(jiffies)</span></code> which sleeps the task for <em>jiffies</em> time.</p>
</div>
<div class="section" id="memory-management">
<h2>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Page</dt><dd><p>The smallest unit of physical memory that the kernel operates on simply because the MMU does that (usually around 4K). Each and every page of physical memory has an associated <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> describing <em>not</em> its data, but its layout.</p>
</dd>
<dt>Zones</dt><dd><p>The kernel cannot trat each page equaly, thus separates them into categories or zones. Each is represented as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">memzone</span></code>. There are a couple of them - the regular case is called <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code>; there is also the memory used for DMA - <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code>; the other important one is <code class="docutils literal notranslate"><span class="pre">ZONE_HIGHMEM</span></code>. There existance is solely based on hardware limitations: DMA could be performed only on certain addresses (e.g ISA is 16-bit). Usually the layout is similar to the following - <code class="docutils literal notranslate"><span class="pre">DMA</span> <span class="pre">&lt;</span> <span class="pre">16MB</span></code>, <code class="docutils literal notranslate"><span class="pre">16MB</span> <span class="pre">&lt;</span> <span class="pre">NORMAL</span> <span class="pre">&lt;</span> <span class="pre">896MB</span></code>, <code class="docutils literal notranslate"><span class="pre">HIGHMEM</span> <span class="pre">&gt;</span> <span class="pre">896MB</span></code> (x86-32).  Each zone is represented as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span></code>.</p>
</dd>
<dt>High memory</dt><dd><p>Some of kernel memory is not permanently mapped - it cannot be addressed. Therefore, there is a memory zone called “high memory”.</p>
</dd>
</dl>
<div class="section" id="allocating-memory">
<h3>Allocating memory<a class="headerlink" href="#allocating-memory" title="Permalink to this headline">¶</a></h3>
<p>There are a couple of different ways for memory allocation. Most of them rely on the page allocation API (check below), which is used for acquiring physical pages. The primary functions are used similarly to the userland <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, but have a slight difference.</p>
<a class="reference internal image-reference" href="_images/pagealloc_api.png"><img alt="_images/pagealloc_api.png" class="align-center" src="_images/pagealloc_api.png" style="width: 778.4px; height: 220.5px;" /></a>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Unlike user-space, the kernel will happilly hang itself if you ask it!</p>
</div>
<dl class="simple">
<dt>gfp_t flags</dt><dd><p>These are flags passed to the allocation functions, which denote the <em>modifiers</em> used - action (<em>how</em> to allocate), zone (<em>where</em> to allocate) and type (predefined combinations of <em>how</em> and <em>where</em>).</p>
</dd>
<dt>kmalloc()</dt><dd><p>This is the equivalance the stdlib’s malloc. Other than the required size, a second parameter is passed as well <code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code>. Returns a physically contigous memory.</p>
</dd>
<dt>vmalloc()</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">kmalloc()</span></code>, with the exception that the memory is only virtually contigous, and not necessarily physically contigous.</p>
</dd>
</dl>
<p>At the end, memory is deallocated by calling the corresponding function - either <code class="docutils literal notranslate"><span class="pre">kfree()</span></code> or <code class="docutils literal notranslate"><span class="pre">vfree()</span></code>, depending on the allocation policy.</p>
</div>
<div class="section" id="slab-layer">
<h3>Slab Layer<a class="headerlink" href="#slab-layer" title="Permalink to this headline">¶</a></h3>
<p>Common phenomenon in kernel is keeping a <em>freelist</em>. This involves a preallocated pool of objects which get reused on “free” rather than actually freeing the memory. Thus, a general mechanism was introduced - the slab layer, which is basically a struct-caching layer.</p>
<p>The structure involves a cache, divided into multiple slabs, each of them composed of memory pages. Each slab contains some number of objects, which get cached. This results in 3 possible states - it is either full, empty or partial. When a request is made (allocation), a partial slab is used. If none exist, an empty is used, and if that does not exist as well, a new slab is allocated with the actual MM API.</p>
<p><em>Slab API</em></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mem_cache_create()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem_cache_destroy()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem_cache_alloc()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mem_cache_free()</span></code></p></li>
</ul>
<dl class="simple">
<dt>Map</dt><dd><p>If a page is not mapped in kernel space but is required. The <code class="docutils literal notranslate"><span class="pre">kmap</span></code> function family is used. Additionally atomic variants are provided as well.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="virtual-filesystem">
<h2>Virtual Filesystem<a class="headerlink" href="#virtual-filesystem" title="Permalink to this headline">¶</a></h2>
<p>The kernel provides an abstracted view to any concrete filesystems that may be implemented until now and in the future. It wrapps the interface provided by them into a general one which is used by the other kernel components when talking to the filesystem layer. The following diagram illustrates this with an example utilizing FUSE.</p>
<a class="reference internal image-reference" href="_images/vfs_struct.png"><img alt="_images/vfs_struct.png" class="align-center" src="_images/vfs_struct.png" style="width: 441.0px; height: 334.2px;" /></a>
<p>Additionally, the VFS layer enables different filesystems to communicate with eachother, e.g copy FAT files to ext3.</p>
<a class="reference internal image-reference" href="_images/vfs_flow.png"><img alt="_images/vfs_flow.png" class="align-center" src="_images/vfs_flow.png" style="width: 531.6px; height: 124.19999999999999px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The VFS layer is considered a good example of OOP implemented in C.</p>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>There are four primary objects which VFS recognises</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Superblock</strong> - Specific mounted filesystem</p></li>
<li><p><strong>Inode</strong> - File metadata</p></li>
<li><p><strong>Dentry</strong> - Single path component</p></li>
<li><p><strong>File</strong> - Opened file. Associated with a process</p></li>
</ul>
</div></blockquote>
<p>Each of them contains a related <em>operations</em> object.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>super_operations</strong> - <code class="docutils literal notranslate"><span class="pre">write_inode()</span></code>, <code class="docutils literal notranslate"><span class="pre">sync_fs()</span></code></p></li>
<li><p><strong>inode_operations</strong> - <code class="docutils literal notranslate"><span class="pre">create()</span></code>, <code class="docutils literal notranslate"><span class="pre">link()</span></code></p></li>
<li><p><strong>dentry_operations</strong> - <code class="docutils literal notranslate"><span class="pre">d_delete()</span></code>, <code class="docutils literal notranslate"><span class="pre">d_compare()</span></code></p></li>
<li><p><strong>file_operations</strong> - <code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code></p></li>
</ul>
</div></blockquote>
<p>For the most part, these methods may use the base implementation.</p>
<p>Each <em>registered</em> filesystem is represented as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span></code>.</p>
<p>Each mountpoint is represented as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The UNIX fs concepts are physically mapped on disk. VFS is designed to work with these concepts, thus requiring each concrete filesystem to provide them. That is the case even for non-UNIX filesystem such as FAT or NTFS to provide the <em>appearance</em> of these concepts.</p>
</div>
</div>
<div class="section" id="superblock">
<h3>Superblock<a class="headerlink" href="#superblock" title="Permalink to this headline">¶</a></h3>
<p>Represented as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span></code> from <code class="docutils literal notranslate"><span class="pre">&lt;linux/fs.h&gt;</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_list</span><span class="p">;</span><span class="w">               </span><span class="cm">/* list of all superblocks */</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">         </span><span class="kt">dev_t</span><span class="w"> </span><span class="n">s_dev</span><span class="p">;</span><span class="w">                           </span><span class="cm">/* identifier */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">s_blocksize</span><span class="p">;</span><span class="w">             </span><span class="cm">/* block size in bytes */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">s_blocksize_bits</span><span class="p">;</span><span class="w">        </span><span class="cm">/* block size in bits */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">s_dirt</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* dirty flag */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">s_maxbytes</span><span class="p">;</span><span class="w">         </span><span class="cm">/* max file size */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">         </span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="n">s_type</span><span class="p">;</span><span class="w">        </span><span class="cm">/* filesystem type */</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">         </span><span class="k">struct</span> <span class="nc">super_operations</span><span class="w"> </span><span class="n">s_op</span><span class="p">;</span><span class="w">          </span><span class="cm">/* superblock methods */</span><span class="w"></span>
<span class="linenos">10</span><span class="w">         </span><span class="k">struct</span> <span class="nc">dquot_operations</span><span class="w"> </span><span class="o">*</span><span class="n">dq_op</span><span class="p">;</span><span class="w">        </span><span class="cm">/* quota methods */</span><span class="w"></span>
<span class="linenos">11</span><span class="w">         </span><span class="k">struct</span> <span class="nc">quotactl_ops</span><span class="w"> </span><span class="o">*</span><span class="n">s_qcop</span><span class="p">;</span><span class="w">           </span><span class="cm">/* quota control methods */</span><span class="w"></span>
<span class="linenos">12</span><span class="w">         </span><span class="k">struct</span> <span class="nc">export_operations</span><span class="w"> </span><span class="o">*</span><span class="n">s_export_op</span><span class="p">;</span><span class="w"> </span><span class="cm">/* export methods */</span><span class="w"></span>
<span class="linenos">13</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">s_flags</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* mount flags */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">s_magic</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* filesystem’s magic number */</span><span class="w"></span>
<span class="linenos">15</span><span class="w">         </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">s_root</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* directory mount point */</span><span class="w"></span>
<span class="linenos">16</span><span class="w">         </span><span class="k">struct</span> <span class="nc">rw_semaphore</span><span class="w"> </span><span class="n">s_umount</span><span class="p">;</span><span class="w">          </span><span class="cm">/* unmount semaphore */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">         </span><span class="k">struct</span> <span class="nc">semaphore</span><span class="w"> </span><span class="n">s_lock</span><span class="p">;</span><span class="w">               </span><span class="cm">/* superblock semaphore */</span><span class="w"></span>
<span class="linenos">18</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">s_count</span><span class="p">;</span><span class="w">                           </span><span class="cm">/* superblock ref count */</span><span class="w"></span>
<span class="linenos">19</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">s_need_sync</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* not-yet-synced flag */</span><span class="w"></span>
<span class="linenos">20</span><span class="w">         </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">s_active</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* active reference count */</span><span class="w"></span>
<span class="linenos">21</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">s_security</span><span class="p">;</span><span class="w">                      </span><span class="cm">/* security module */</span><span class="w"></span>
<span class="linenos">22</span><span class="w">         </span><span class="k">struct</span> <span class="nc">xattr_handler</span><span class="w"> </span><span class="o">**</span><span class="n">s_xattr</span><span class="p">;</span><span class="w">        </span><span class="cm">/* extended attribute handlers */</span><span class="w"></span>
<span class="linenos">23</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_inodes</span><span class="p">;</span><span class="w">             </span><span class="cm">/* list of inodes */</span><span class="w"></span>
<span class="linenos">24</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_dirty</span><span class="p">;</span><span class="w">              </span><span class="cm">/* list of dirty inodes */</span><span class="w"></span>
<span class="linenos">25</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_io</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* list of writebacks */</span><span class="w"></span>
<span class="linenos">26</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_moreio</span><span class="p">;</span><span class="w">             </span><span class="cm">/* list of writebacks */</span><span class="w"></span>
<span class="linenos">27</span><span class="w">         </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="n">s_anon</span><span class="p">;</span><span class="w">              </span><span class="cm">/* anonymous dentries */</span><span class="w"></span>
<span class="linenos">28</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_files</span><span class="p">;</span><span class="w">              </span><span class="cm">/* list of assigned files */</span><span class="w"></span>
<span class="linenos">29</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_dentry_lr</span><span class="p">;</span><span class="w">          </span><span class="cm">/* list of unused dentries */</span><span class="w"></span>
<span class="linenos">30</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">s_nr_dentry_unused</span><span class="p">;</span><span class="w">                </span><span class="cm">/* number of dentries in s_dentry_lru */</span><span class="w"></span>
<span class="linenos">31</span><span class="w">         </span><span class="k">struct</span> <span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="n">bdev</span><span class="p">;</span><span class="w">             </span><span class="cm">/* assiciated block device */</span><span class="w"></span>
<span class="linenos">32</span><span class="w">         </span><span class="k">struct</span> <span class="nc">mtd_info</span><span class="w"> </span><span class="o">*</span><span class="n">s_mtd</span><span class="p">;</span><span class="w">                </span><span class="cm">/* memory disk information */</span><span class="w"></span>
<span class="linenos">33</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">s_instances</span><span class="p">;</span><span class="w">          </span><span class="cm">/* instances of this fs */</span><span class="w"></span>
<span class="linenos">34</span><span class="w">         </span><span class="k">struct</span> <span class="nc">quota_info</span><span class="w"> </span><span class="n">s_dquot</span><span class="p">;</span><span class="w">             </span><span class="cm">/* quota-specific operations */</span><span class="w"></span>
<span class="linenos">35</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">s_frozen</span><span class="p">;</span><span class="w">                          </span><span class="cm">/* frozen status */</span><span class="w"></span>
<span class="linenos">36</span><span class="w">         </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">s_wait_unfrozen</span><span class="p">;</span><span class="w">     </span><span class="cm">/* wait queue on freeze */</span><span class="w"></span>
<span class="linenos">37</span><span class="w">         </span><span class="kt">char</span><span class="w"> </span><span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w">                         </span><span class="cm">/* text name */</span><span class="w"></span>
<span class="linenos">38</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* filesystem-specific info */</span><span class="w"></span>
<span class="linenos">39</span><span class="w">         </span><span class="n">fmode_t</span><span class="w"> </span><span class="n">s_mode</span><span class="p">;</span><span class="w">                        </span><span class="cm">/* mount permissions */</span><span class="w"></span>
<span class="linenos">40</span><span class="w">         </span><span class="k">struct</span> <span class="nc">semaphore</span><span class="w"> </span><span class="n">s_vfs_rename_sem</span><span class="p">;</span><span class="w">     </span><span class="cm">/* rename semaphore */</span><span class="w"></span>
<span class="linenos">41</span><span class="w">         </span><span class="n">u32</span><span class="w"> </span><span class="n">s_time_gran</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* granularity of timestamps */</span><span class="w"></span>
<span class="linenos">42</span><span class="w">         </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s_subtype</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* subtype name */</span><span class="w"></span>
<span class="linenos">43</span><span class="w">         </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s_options</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* saved mount points */</span><span class="w"></span>
<span class="linenos">44</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>One of the key members of the super’s structure is <code class="docutils literal notranslate"><span class="pre">s_op</span></code>, which is essentially a “vtable” of concrete fs’ operations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span> <span class="nc">super_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos"> 3</span><span class="cm">          * create and init an inode under the given fs</span>
<span class="linenos"> 4</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">         </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos"> 8</span><span class="cm">          * deallocate given inode</span>
<span class="linenos"> 9</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">10</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="n">super</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">13</span><span class="cm">          * given inode is modified</span>
<span class="linenos">14</span><span class="cm">          * used for journaling</span>
<span class="linenos">15</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">16</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)(</span><span class="n">super</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">19</span><span class="cm">          * write given inode to disk</span>
<span class="linenos">20</span><span class="cm">          * sync or async depending on wait</span>
<span class="linenos">21</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">22</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)(</span><span class="n">super</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">25</span><span class="cm">          * called when the refcount = 0</span>
<span class="linenos">26</span><span class="cm">          * the inode is deleted</span>
<span class="linenos">27</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">28</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">31</span><span class="cm">          * delete inode from disk</span>
<span class="linenos">32</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">33</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">delete_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">36</span><span class="cm">          * release superblock object; called on unmount</span>
<span class="linenos">37</span><span class="cm">          * s_lock has be held</span>
<span class="linenos">38</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">39</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">42</span><span class="cm">          * synchronises the disk version with the memory version of a given superblock</span>
<span class="linenos">43</span><span class="cm">          * s_lock is required</span>
<span class="linenos">44</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">45</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_super</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos">48</span><span class="cm">          * synchronises fs metadata on disk with memory</span>
<span class="linenos">49</span><span class="cm">          * sync or async depending on wait</span>
<span class="linenos">50</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">51</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="linenos">52</span>
<span class="linenos">53</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">55</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">kstatfs</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">56</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">57</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clear_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">58</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">59</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_options</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">60</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="linenos">61</span><span class="w">         </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_read</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span><span class="w"></span>
<span class="linenos">62</span><span class="w">         </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_write</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span><span class="w"></span>
<span class="linenos">63</span><span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">bdev_try_to_free_page</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="p">);</span><span class="w"></span>
<span class="linenos">64</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="inode">
<h3>Inode<a class="headerlink" href="#inode" title="Permalink to this headline">¶</a></h3>
<p>Constructed in memory in a manner suitable for the concrete FS. Stores all required information in order to safely manipulate files and directories.</p>
<p>As with <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span></code>, there is an operations member.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span> <span class="nc">inode_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">        </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">symlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rmdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mknod</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">readonly</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">follow_link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">put_link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">truncate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">permissions</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">16</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setxattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getxattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">20</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">listxattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">removexattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">truncate_range</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fallocate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fiemap</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">25</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="dentry">
<h3>Dentry<a class="headerlink" href="#dentry" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span> <span class="nc">dentry</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">        </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">d_count</span><span class="p">;</span><span class="w">        </span><span class="cm">/* usage count */</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">d_flags</span><span class="p">;</span><span class="w">        </span><span class="cm">/* dentry flags */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">        </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">d_lock</span><span class="p">;</span><span class="w">         </span><span class="cm">/* per-dentry lock */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="kt">int</span><span class="w">             </span><span class="n">d_mounted</span><span class="p">;</span><span class="w">      </span><span class="cm">/* is this a mount point */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">        </span><span class="k">struct</span> <span class="nc">inode</span><span class="w">    </span><span class="o">*</span><span class="n">d_inode</span><span class="p">;</span><span class="w">       </span><span class="cm">/* associated inode */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="n">d_hash</span><span class="p">;</span><span class="w">       </span><span class="cm">/* list of hash table entries */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="k">struct</span> <span class="nc">dentry</span><span class="w">   </span><span class="o">*</span><span class="n">d_parent</span><span class="p">;</span><span class="w">      </span><span class="cm">/* dentry object of parent */</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">        </span><span class="k">struct</span> <span class="nc">qstr</span><span class="w">     </span><span class="n">d_name</span><span class="p">;</span><span class="w">         </span><span class="cm">/* dentry name */</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">d_lru</span><span class="p">;</span><span class="w">         </span><span class="cm">/* unused list */</span><span class="w"></span>
<span class="linenos">11</span><span class="w">        </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">                </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">d_child</span><span class="p">;</span><span class="w">       </span><span class="cm">/* list of dentries within */</span><span class="w"></span>
<span class="linenos">13</span><span class="w">                </span><span class="k">struct</span> <span class="nc">rcu_head</span><span class="w"> </span><span class="n">d_rcu</span><span class="p">;</span><span class="w">          </span><span class="cm">/* RCU locking */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">d_u</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="w">        </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">        </span><span class="n">d_subdirs</span><span class="p">;</span><span class="w">      </span><span class="cm">/* subdirectories */</span><span class="w"></span>
<span class="linenos">16</span><span class="w">        </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">        </span><span class="n">d_alias</span><span class="p">;</span><span class="w">        </span><span class="cm">/* list of alias inodes */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">            </span><span class="n">d_time</span><span class="p">;</span><span class="w">         </span><span class="cm">/* revalidate time */</span><span class="w"></span>
<span class="linenos">18</span><span class="w">        </span><span class="k">struct</span> <span class="nc">dentry_operations</span><span class="w"> </span><span class="o">*</span><span class="n">d_op</span><span class="p">;</span><span class="w">         </span><span class="cm">/* dentry operations vtable */</span><span class="w"></span>
<span class="linenos">19</span><span class="w">        </span><span class="k">struct</span> <span class="nc">super_block</span><span class="w">      </span><span class="o">*</span><span class="n">d_sb</span><span class="p">;</span><span class="w">          </span><span class="cm">/* superblock of file */</span><span class="w"></span>
<span class="linenos">20</span><span class="w">        </span><span class="kt">void</span><span class="w">                    </span><span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span><span class="w">      </span><span class="cm">/* fs-specific data */</span><span class="w"></span>
<span class="linenos">21</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN_MIN</span><span class="p">];</span><span class="w"> </span><span class="cm">/* short name */</span><span class="w"></span>
<span class="linenos">22</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Each entry is in one of the following states - either unsed, unused or negative.</p>
<blockquote>
<div><ul class="simple">
<li><p>Used - has a corresponding inode which is valid. There are valid users and cannot be discarded. (<code class="docutils literal notranslate"><span class="pre">d_count</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>)</p></li>
<li><p>Unused - has a corresponding inode which is valid. No users (<code class="docutils literal notranslate"><span class="pre">d_count</span> <span class="pre">==</span> <span class="pre">0</span></code>)</p></li>
<li><p>Negative - no associated inode (<code class="docutils literal notranslate"><span class="pre">d_inode</span> <span class="pre">==</span> <span class="pre">NULL</span></code>). It is kept around, so that future lookups could be resolved quickly.</p></li>
</ul>
</div></blockquote>
<p>Usually when a dentry name is resolved, there have been mulitple components in the path leading to it. Therefore, multiple “temporary” dentries have been resolved for (almost) nothing. Thus, the VFS keeps those in the <em>dcache</em>. It consists of three elements:</p>
<blockquote>
<div><ul class="simple">
<li><p>Used</p></li>
<li><p>LRU</p></li>
<li><p>Hashtable, mapping string path to dentry</p></li>
</ul>
</div></blockquote>
<p>Additionally, the dcache provides the frontend to the <em>icache</em>. As long as a dentry is cached, its associated inode is cached as well.</p>
<dl class="simple">
<dt>⇒ Locality</dt><dd><ol class="arabic simple">
<li><p>Temporal - programs tend to access the same files, and</p></li>
<li><p>Spatial - programs tend to access files from the same directory</p></li>
</ol>
</dd>
</dl>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">         </span><span class="k">struct</span> <span class="nc">dentry_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos"> 4</span><span class="cm">                  * called when fetching from the dcache to check if the dentry valid</span>
<span class="linenos"> 5</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_revalidate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos"> 9</span><span class="cm">                  * hash the dentry</span>
<span class="linenos">10</span><span class="cm">                  * called when placing in the dcache hashtable</span>
<span class="linenos">11</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos">12</span><span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_hash</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos">15</span><span class="cm">                  * compare two filenames</span>
<span class="linenos">16</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_compare</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos">20</span><span class="cm">                  * called on d_count = 0</span>
<span class="linenos">21</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos">22</span><span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_delete</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos">25</span><span class="cm">                  * free</span>
<span class="linenos">26</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos">27</span><span class="w">                 </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_release</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w">                 </span><span class="cm">/*</span>
<span class="linenos">30</span><span class="cm">                  * if a dentry loses its inode (freed)</span>
<span class="linenos">31</span><span class="cm">                  */</span><span class="w"></span>
<span class="linenos">32</span><span class="w">                 </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_iput</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">33</span>
<span class="linenos">34</span><span class="w">                 </span><span class="kt">char</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_dname</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="linenos">35</span><span class="w">         </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="file">
<h3>File<a class="headerlink" href="#file" title="Permalink to this headline">¶</a></h3>
<p>The in-memory representation of an open file.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">         </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">                 </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">fu_list</span><span class="p">;</span><span class="w">              </span><span class="cm">/* list of file objects */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">                 </span><span class="k">struct</span> <span class="nc">rcu_head</span><span class="w"> </span><span class="n">fu_rcuhead</span><span class="p">;</span><span class="w">            </span><span class="cm">/* RCU list after freeing */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">         </span><span class="p">}</span><span class="w"> </span><span class="n">f_u</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">         </span><span class="k">struct</span> <span class="nc">path</span><span class="w">    </span><span class="n">f_path</span><span class="p">;</span><span class="w">                         </span><span class="cm">/* contains the dentry - f_path.dentry */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">         </span><span class="k">struct</span> <span class="nc">file_operations</span><span class="w"> </span><span class="o">*</span><span class="n">f_op</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* file operations vtable */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">         </span><span class="n">spinlock_t</span><span class="w">     </span><span class="n">f_lock</span><span class="p">;</span><span class="w">                         </span><span class="cm">/* per-file struct lock */</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">         </span><span class="n">atomic_t</span><span class="w">       </span><span class="n">f_count</span><span class="p">;</span><span class="w">                        </span><span class="cm">/* usage count */</span><span class="w"></span>
<span class="linenos">10</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">f_flags</span><span class="p">;</span><span class="w">                        </span><span class="cm">/* specified on open */</span><span class="w"></span>
<span class="linenos">11</span><span class="w">         </span><span class="kt">mode_t</span><span class="w">         </span><span class="n">f_mode</span><span class="p">;</span><span class="w">                         </span><span class="cm">/* access mode */</span><span class="w"></span>
<span class="linenos">12</span><span class="w">         </span><span class="n">loff_t</span><span class="w">         </span><span class="n">f_pos</span><span class="p">;</span><span class="w">                          </span><span class="cm">/* offset */</span><span class="w"></span>
<span class="linenos">13</span><span class="w">         </span><span class="k">struct</span> <span class="nc">fown_struct</span><span class="w">     </span><span class="n">f_owner</span><span class="p">;</span><span class="w">                </span><span class="cm">/* owner data for signals */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w">      </span><span class="o">*</span><span class="n">f_cred</span><span class="p">;</span><span class="w">                </span><span class="cm">/* file credentials */</span><span class="w"></span>
<span class="linenos">15</span><span class="w">         </span><span class="k">struct</span> <span class="nc">file_ra_state</span><span class="w">   </span><span class="n">f_ra</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* read-ahead state */</span><span class="w"></span>
<span class="linenos">16</span><span class="w">         </span><span class="n">u64</span><span class="w">            </span><span class="n">f_version</span><span class="p">;</span><span class="w">                      </span><span class="cm">/* version number */</span><span class="w"></span>
<span class="linenos">17</span><span class="w">         </span><span class="kt">void</span><span class="w">           </span><span class="o">*</span><span class="n">f_security</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* security module */</span><span class="w"></span>
<span class="linenos">18</span><span class="w">         </span><span class="kt">void</span><span class="w">           </span><span class="o">*</span><span class="n">private_data</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* tty driver hook */</span><span class="w"></span>
<span class="linenos">19</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">       </span><span class="n">f_ep_links</span><span class="p">;</span><span class="w">             </span><span class="cm">/* list of epoll links */</span><span class="w"></span>
<span class="linenos">20</span><span class="w">         </span><span class="n">spinlock_t</span><span class="w">     </span><span class="n">f_ep_lock</span><span class="p">;</span><span class="w">                      </span><span class="cm">/* epoll lock */</span><span class="w"></span>
<span class="linenos">21</span><span class="w">         </span><span class="k">struct</span> <span class="nc">address_space</span><span class="w">   </span><span class="o">*</span><span class="n">f_mapping</span><span class="p">;</span><span class="w">             </span><span class="cm">/* page cache mapping */</span><span class="w"></span>
<span class="linenos">22</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">   </span><span class="n">f_mnt_write_state</span><span class="p">;</span><span class="w">              </span><span class="cm">/* debugging state */</span><span class="w"></span>
<span class="linenos">23</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="filesystem-related-structs">
<h3>Filesystem Related Structs<a class="headerlink" href="#filesystem-related-structs" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">      </span><span class="cm">/* fs name */</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">         </span><span class="kt">int</span><span class="w">         </span><span class="n">fs_flags</span><span class="p">;</span><span class="w">  </span><span class="cm">/* type flags */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">         </span><span class="k">struct</span> <span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_sb</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w">         </span><span class="cm">/* reads the superblock off the disk */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">         </span><span class="kt">void</span><span class="w">           </span><span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w">     </span><span class="cm">/* terminates access to the superblock */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">         </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w">  </span><span class="cm">/* owner of the fs */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">         </span><span class="k">struct</span> <span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">fs_supers</span><span class="p">;</span><span class="w">    </span><span class="cm">/* list of superblock objects */</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">         </span><span class="c1">// runtime lock validation</span>
<span class="linenos">11</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_lock_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_umount_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_lock_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">14</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_mutex_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_mutex_dir_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">16</span><span class="w">         </span><span class="k">struct</span> <span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_alloc_sem_key</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Each file system gets on of these regardless whether it is even mounted at all. When it gets mounted, a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span></code> is created.</p>
</div>
<div class="section" id="process-related-structs">
<h3>Process Related Structs<a class="headerlink" href="#process-related-structs" title="Permalink to this headline">¶</a></h3>
<p>Each process has its own</p>
<blockquote>
<div><ul class="simple">
<li><p>Open files</p></li>
<li><p>Current directory</p></li>
<li><p>Root filesystem</p></li>
<li><p>Mount points</p></li>
</ul>
</div></blockquote>
<p>(and more actually).</p>
<p>There are a couple of structures which are used in order to tie VFS with a process.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">        </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">count</span><span class="p">;</span><span class="w">          </span><span class="cm">/* usage count */</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">        </span><span class="k">struct</span> <span class="nc">fdtable</span><span class="w">  </span><span class="o">*</span><span class="n">fdt</span><span class="p">;</span><span class="w">           </span><span class="cm">/* pointer to other fdtable */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">        </span><span class="k">struct</span> <span class="nc">fd</span><span class="w">       </span><span class="n">fdtab</span><span class="p">;</span><span class="w">          </span><span class="cm">/* base fd table */</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">file_lock</span><span class="p">;</span><span class="w">      </span><span class="cm">/* per-file lock */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">        </span><span class="kt">int</span><span class="w">             </span><span class="n">next_fd</span><span class="p">;</span><span class="w">        </span><span class="cm">/* cache of next available fd */</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">struct</span> <span class="nc">embedded_fd_set</span><span class="w">  </span><span class="n">close_on_exec_init</span><span class="p">;</span><span class="w">     </span><span class="cm">/* list of close-on-exec fds */</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="k">struct</span> <span class="nc">embedded_fd_set</span><span class="w">  </span><span class="n">open_fds_init</span><span class="p">;</span><span class="w">          </span><span class="cm">/* list of open fds */</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">        </span><span class="cm">/*</span>
<span class="linenos">11</span><span class="cm">         * If the process allocates morethen NR_OPEN_DEFAULT (usually 64),</span>
<span class="linenos">12</span><span class="cm">         * the fdt is allocated to point at a new array.</span>
<span class="linenos">13</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">        </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">fd_array</span><span class="p">[</span><span class="n">NR_OPEN_DEFAULT</span><span class="p">];</span><span class="w"></span>
<span class="linenos">15</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">struct</span> <span class="nc">fs_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">2</span><span class="w">        </span><span class="kt">int</span><span class="w">    </span><span class="n">users</span><span class="p">;</span><span class="w">          </span><span class="cm">/* user count */</span><span class="w"></span>
<span class="linenos">3</span><span class="w">        </span><span class="n">rwlock_t</span><span class="w">      </span><span class="n">lock</span><span class="p">;</span><span class="w">    </span><span class="cm">/* lock */</span><span class="w"></span>
<span class="linenos">4</span><span class="w">        </span><span class="kt">int</span><span class="w">    </span><span class="n">umask</span><span class="p">;</span><span class="w"></span>
<span class="linenos">5</span><span class="w">        </span><span class="kt">int</span><span class="w">    </span><span class="n">in_exec</span><span class="p">;</span><span class="w">        </span><span class="cm">/* currently executing a file */</span><span class="w"></span>
<span class="linenos">6</span><span class="w">        </span><span class="k">struct</span> <span class="nc">path</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w"></span>
<span class="linenos">7</span><span class="w">        </span><span class="k">struct</span> <span class="nc">path</span><span class="w"> </span><span class="n">pwd</span><span class="p">;</span><span class="w"></span>
<span class="linenos">8</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w">         </span><span class="k">struct</span> <span class="nc">mnt_namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">2</span><span class="w">                 </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="linenos">3</span><span class="w">                 </span><span class="k">struct</span> <span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="p">;</span><span class="w"></span>
<span class="linenos">4</span><span class="w">                 </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w"></span>
<span class="linenos">5</span><span class="w">                 </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">poll</span><span class="p">;</span><span class="w"></span>
<span class="linenos">6</span><span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">event</span><span class="p">;</span><span class="w"></span>
<span class="linenos">7</span><span class="w">         </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">clone()</span></code> function is called and the <code class="docutils literal notranslate"><span class="pre">CLONE_FS</span></code> flag is specified, that addresses the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_struct</span></code>. Similarly, there are also <code class="docutils literal notranslate"><span class="pre">CLONE_FILES</span></code> and <code class="docutils literal notranslate"><span class="pre">CLONE_NEWNS</span></code> (about <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">files_struct</span></code> and <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_namespace</span></code> respectively).</p>
</div>
</div>
</div>
<div class="section" id="block-i-o">
<h2>Block I/O<a class="headerlink" href="#block-i-o" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Block device</dt><dd><p>Random access of fixed-size chunk of data (blocks). Filesystems are mounted on such. (hdd, ssd, blueray, etc.)</p>
</dd>
<dt>Character device</dt><dd><p>Stream of sequential data. (keyboard, serial port, etc.). Cannot call <code class="docutils literal notranslate"><span class="pre">seek()</span></code> on them.</p>
</dd>
</dl>
<p>The block I/O layer manages block devices and the access to them.</p>
<div class="section" id="block-device">
<h3>Block Device<a class="headerlink" href="#block-device" title="Permalink to this headline">¶</a></h3>
<p>The smallest unit of memory in a block device is called <em>sector</em> (usually 512B). The software which manages the block devices imposes a logical size (usually 1K or 4K).</p>
<a class="reference internal image-reference" href="_images/block_sector_mapping.png"><img alt="_images/block_sector_mapping.png" class="align-center" src="_images/block_sector_mapping.png" style="width: 450.75px; height: 289.5px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sector size &lt;= Block size &lt;= Page size</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Sector and block do not have the same meaning. Sectors are called “<em>hard</em> sectors” and “<em>device</em> blocks” as well, whereas the logical blocks may be called “filesystem blocks” or “I/O blocks”.</p>
</div>
</div>
<div class="section" id="buffer">
<h3>Buffer<a class="headerlink" href="#buffer" title="Permalink to this headline">¶</a></h3>
<p>Each time an actual read from the physical storage is performed, the received block is stored in a buffer. Each buffer is associated with <strong>exactly 1 filesystem block</strong> and is its in-memory representation. Each buffer is referenced by a descriptor - <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span></code>. It stores information like the block device, the block number, etc.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm"> * &lt;linux/buffer_head.h&gt;</span>
<span class="linenos"> 3</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="w"> </span><span class="k">struct</span> <span class="nc">buffer_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">         </span><span class="cm">/*</span>
<span class="linenos"> 7</span><span class="cm">          * BH_Uptodate</span>
<span class="linenos"> 8</span><span class="cm">          * BH_Dirty</span>
<span class="linenos"> 9</span><span class="cm">          * BH_Lock</span>
<span class="linenos">10</span><span class="cm">          * BH_Req</span>
<span class="linenos">11</span><span class="cm">          * BH_Mapped</span>
<span class="linenos">12</span><span class="cm">          * and (many) others</span>
<span class="linenos">13</span><span class="cm">          */</span><span class="w"></span>
<span class="linenos">14</span><span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b_state</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">         </span><span class="k">struct</span> <span class="nc">buffer_head</span><span class="w"> </span><span class="o">*</span><span class="n">b_this_page</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w">         </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">b_page</span><span class="p">;</span><span class="w"></span>
<span class="linenos">18</span><span class="w">         </span><span class="n">sector_t</span><span class="w"> </span><span class="n">b_blocknr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="w">         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">b_size</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="w">         </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">b_data</span><span class="p">;</span><span class="w"></span>
<span class="linenos">21</span><span class="w">         </span><span class="k">struct</span> <span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="n">b_bdev</span><span class="p">;</span><span class="w"></span>
<span class="linenos">22</span><span class="w">         </span><span class="n">bh_end_io</span><span class="w"> </span><span class="o">*</span><span class="n">b_end_io</span><span class="p">;</span><span class="w"></span>
<span class="linenos">23</span><span class="w">         </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">b_private</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">         </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">b_assoc_buffers</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">         </span><span class="k">struct</span> <span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="n">b_assoc_map</span><span class="p">;</span><span class="w"></span>
<span class="linenos">26</span><span class="w">         </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">b_count</span><span class="p">;</span><span class="w"></span>
<span class="linenos">27</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>There is an issue with this model: when used for container for all I/O operations, the buffer_head forces the kernel to break up (pottentially) large block I/O operations (say, a write) into many buffer_head structures. Therefore, another struct appears at this level - <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p>
</div>
<div class="section" id="bio">
<h3>Bio<a class="headerlink" href="#bio" title="Permalink to this headline">¶</a></h3>
<p>Represents block <em>already on the flight</em> as a list of segments. A segment is defined as a contiguous chunk in memory. Therefore, the individual buffers need not be contiguous in memory. This is called <em>scatter-gather I/O</em>. <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>’s most important members are the array of individual vectors (<code class="docutils literal notranslate"><span class="pre">bi_io_vec</span></code>), the length of this array (<code class="docutils literal notranslate"><span class="pre">bi_cnt</span></code>) and the index to the currently-processed vector (<code class="docutils literal notranslate"><span class="pre">bi_idx</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The existance of the <code class="docutils literal notranslate"><span class="pre">bi_idx</span></code> member allows a single <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> to be split among several medias (e.g RAID). The only setup required is to copy the <code class="docutils literal notranslate"><span class="pre">bio</span></code> instance and to modify the value of <code class="docutils literal notranslate"><span class="pre">bi_idx</span></code> to point to the correct entry in the vector array.</p>
</div>
<a class="reference internal image-reference" href="_images/bio.png"><img alt="_images/bio.png" class="align-center" src="_images/bio.png" style="width: 505.79999999999995px; height: 391.8px;" /></a>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span> <span class="nc">bio_vec</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w">        </span><span class="cm">/*</span>
<span class="linenos"> 4</span><span class="cm">         * pointer to the physical page on which the buffer resides</span>
<span class="linenos"> 5</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">        </span><span class="k">struct</span> <span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">bv_page</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">        </span><span class="cm">/*</span>
<span class="linenos"> 9</span><span class="cm">         * the length of this buffer (bytes)</span>
<span class="linenos">10</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos">11</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bv_len</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">        </span><span class="cm">/*</span>
<span class="linenos">14</span><span class="cm">         * the byte offset within the page where the buffer resides</span>
<span class="linenos">15</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos">16</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bv_offset</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="i-o-scheduler">
<h3>I/O Scheduler<a class="headerlink" href="#i-o-scheduler" title="Permalink to this headline">¶</a></h3>
<p>Each time a high-level kernel component wants to perform block I/O it submits a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span></code> to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span></code>. However, if the disk driver performs each operation request on the queue in order, the system will have poor performance. Therefore an additional layer is introduced, which sorts and merges request in order to minimize seek time - the I/O scheduler. Its goal is <strong>not to be fair</strong>, but to maximize <em>global throughput</em>.</p>
<dl class="simple">
<dt>Merging</dt><dd><p>The scheduler coalesces multiple request into a single one, thus reducing the overhead of multiple operations. This may be useful only of the blocks are sequentical, i.e request 1 manipulates block N, whereas request 2 manipulates block N+1.</p>
</dd>
<dt>Sorting</dt><dd><p>The entire request queue is maintaned sorted by the sector numbers.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I/O schedulers are also called <em>elevators</em> because their goal is similar to an elevator - to move gracefully in a <em>single</em> direction.</p>
</div>
<dl>
<dt>The Linus Elevator</dt><dd><p>Supports both sorting and merging (front and back).</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If a request on an adjacent on-disk sector is in the queue, the existing request and the new one are merged into a single one.</p></li>
<li><p>If a request on the queue is sufficiently old, the new request is inserted at the tail in order to prevent starvation of older requests.</p></li>
<li><p>If a suitable location sector-wise is found in the queue, the new request is inserted there.</p></li>
<li><p>Else, the new request is inserted at the end of the queue.</p></li>
</ol>
</div></blockquote>
<p>This aging mechanism is not very efficient, although it reduces latency in some cases.</p>
<p><em>Code is in ``block/elevator.c``</em></p>
</dd>
<dt>The Deadline I/O Scheduler</dt><dd><p>Aims at reducing request starvation - the limitation of the linus elevator, and more specifically <em>read starvation</em>. Each request is assigned an expiration time (by default 500ms for reads and 5s for writes). The scheduler again keeps a queue sorted by on-disk sectors, but additionally there are additional read and write queues, which are sorted by expiration time. All requests are in the sorted queue, but are referenced by the othre ones. Each time a new request has to be performed, the heads of the read and write queues are checked and if either one of them have expired it adds them to the dispatch queue, otherwise the head of the sorted queue is taken. Then, the dispatch queue is fed to the disk driver. This algoroithm minimises seek time as well as read request starvation but decreases global throughput.</p>
<p><em>Code is in ``block/deadline-iosched.c``</em></p>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/deadline_elevator.png"><img alt="_images/deadline_elevator.png" class="align-center" src="_images/deadline_elevator.png" style="width: 637.6px; height: 207.20000000000002px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Reads vs Writes</p>
<p>When a write request is issued, the kernel does not perform the operation immediately, but instead after some <em>definite</em> time when it is more suitable. Thus, we say that <strong>writes are asynchronous to the application submitting them</strong>.</p>
<p>However, whena an application wants to read something it is blocked until the read() returns with the specified data. Therefore, <strong>reads are synchronous to the application</strong>. Moreover, reads are dependent on each other.</p>
</div>
<dl>
<dt>The Anticipatory I/O Scheduler</dt><dd><p>This is based on the Deadline Scheduler but has the additional <em>anticipation heuristic</em>. After a read is handled (in the exact same way as the deadline would), instead of seeking back to the previous position, this algorithm <em>waits for some time</em> expecting another read request to be issued to the same disk region (a few ms).</p>
<p><em>Code is in ``block/as-iosched.c``</em></p>
</dd>
<dt>The Complete Fair Queueing I/O Scheduler</dt><dd><p>Very different; designed for specialized workloads.</p>
<p>Instead of keeping one global request queue, the CFQ adds each process’ request in its own queue. Then the CFQ executes N requests of each process, switching using a RR algorithm. This guarantees process fairness.</p>
<p>The default Linux I/O scheduler.</p>
<p><em>Code is in ``block/cfq-iosched.c``</em></p>
</dd>
<dt>The Noop I/O Scheduler</dt><dd><p>Its only responsibility is to perform merging. This algorithm is <strong>designed for a truly random-access devices</strong> (e.g flash mem cards) where there is ~0 seek latency.</p>
<p><em>Code is in ``block/noop-iosched.c``</em></p>
</dd>
</dl>
</div>
</div>
<div class="section" id="process-address-space">
<h2>Process Address Space<a class="headerlink" href="#process-address-space" title="Permalink to this headline">¶</a></h2>
<p>The “Memory Management” chapter discusses how the kernel memory is managed, whereas this one talks about how the user-space memory is managed.</p>
<a class="reference internal image-reference" href="_images/proc_addr_space.png"><img alt="_images/proc_addr_space.png" class="align-center" src="_images/proc_addr_space.png" style="width: 508.8px; height: 382.40000000000003px;" /></a>
<dl class="simple">
<dt>Flat Address Space</dt><dd><p>Each process is given 32- or 64-bit address space in a <em>single</em> range (e.g 0x00 up to 0xFFFFF…). Flat denotes that it is not <em>segmented</em>.</p>
</dd>
<dt>Memory Descriptor</dt><dd><p>Each process’ address space is associated with a memory descriptor (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span></code>). All memory descriptors are kept in a doubly-linked list (the first one is <code class="docutils literal notranslate"><span class="pre">init_mm</span></code>). The <code class="docutils literal notranslate"><span class="pre">mm_struct</span></code> is stored in the process descriptor (<code class="docutils literal notranslate"><span class="pre">task_struct</span></code>) in the <code class="docutils literal notranslate"><span class="pre">mm</span></code> field. If a process has its <code class="docutils literal notranslate"><span class="pre">mm</span> <span class="pre">==</span> <span class="pre">NULL</span></code>, then this is a kernel thread.</p>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The “Memory Areas” and “Memory Descriptor” parts should be <em>not</em> read linearly, since they intereference each other.</p>
</div>
<a class="reference internal image-reference" href="_images/vma.jpg"><img alt="_images/vma.jpg" class="align-center" src="_images/vma.jpg" style="width: 400.0px; height: 286.40000000000003px;" /></a>
<dl>
<dt>Memory Areas</dt><dd><p>Also called VMA (Virtual Memory Area). Even though the process is given a “full” address space, it is not allowed to access all of it, but only some parts. The parts are called memory areas. The process may request more memory to be reserved for its private use. Each memory area has some permissions associated with it - readable, writable, executable. Some of possible memory areas include</p>
<blockquote>
<div><ul class="simple">
<li><p><em>text section</em>       executable file’s code</p></li>
<li><p><em>data section</em>       executable file’s global variables</p></li>
<li><p><em>bss section</em> <a class="footnote-reference brackets" href="#f2" id="id2">2</a>        a page full of zeroes, storing unitialized global variables</p></li>
<li><p>memory mapped files</p></li>
<li><p>process’ userland stack</p></li>
<li><p>anonymous mappings (<code class="docutils literal notranslate"><span class="pre">malloc()</span></code>)</p></li>
</ul>
</div></blockquote>
<p>Represented via the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>. The VMA has similar OO apprach as the VFS - each <code class="docutils literal notranslate"><span class="pre">vm_area_struct</span></code> is treated as a <em>unique memory object</em>; each of them has an associated <code class="docutils literal notranslate"><span class="pre">vm_operations_struct</span></code>. Each VMA spans accross the <code class="docutils literal notranslate"><span class="pre">[vm_start;</span> <span class="pre">vm_end)</span></code> region and cannot overlap other VMAs. The aforementioned permissions are kept in <code class="docutils literal notranslate"><span class="pre">vm_flags</span></code>. <strong>Some</strong> of them are</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>VM_READ</strong></p></li>
<li><p><strong>VM_WRITE</strong></p></li>
<li><p><strong>VM_EXEC</strong></p></li>
<li><p><strong>VM_IO</strong></p></li>
<li><p><strong>VM_SHARED</strong></p></li>
<li><p><strong>VM_SHARED</strong></p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/vma.jpg"><img alt="_images/vma.jpg" class="align-center" src="_images/vma.jpg" style="width: 400.0px; height: 286.40000000000003px;" /></a>
<dl class="simple">
<dt>Page Tables</dt><dd><p>Linux uses 3-level page tables in order to map virtual memory addresses to physical - page global directory, page middle directory, page table entries. The containing PGD is stored in each <code class="docutils literal notranslate"><span class="pre">mm_struct</span></code> as <code class="docutils literal notranslate"><span class="pre">pgd</span></code>. In order to speedup to lookup time a TLB (<em>translation lookaside buffer</em>).</p>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/pagetable.png"><img alt="_images/pagetable.png" class="align-center" src="_images/pagetable.png" style="width: 864.6px; height: 301.2px;" /></a>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>BSS stands for “block started by symbol”</p>
</dd>
</dl>
</div>
<div class="section" id="page-cache">
<h2>Page Cache<a class="headerlink" href="#page-cache" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>Read</dt><dd><p>In order to not turn to the disk directly each time a read request is made, a page cache is maintained. It is checked on each <strong>read</strong> request, which results in either <em>cache miss</em> or <em>cache hit</em>.</p>
</dd>
<dt>Write</dt><dd><p>Three possible strategies</p>
<blockquote>
<div><ol class="arabic">
<li><p>No-write Cache:      Nothing is done. The write is performed directly to the disk.</p></li>
<li><p>Write-through Cache: The cache is updated and the modifications are written immediately to the disk.</p></li>
<li><p>Write-back Cache:    The cache is updated and the page is marked as <em>dirty</em> and is added to the <em>dirty list</em>. From time to time the disked is synchronised with the <em>dirty cache</em> and the dirty flag is toggled. This is done by the “flusher threads”.</p>
<blockquote>
<div><ul class="simple">
<li><p>Linux uses this.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</dd>
<dt>Eviction</dt><dd><p>What pages to remove from the cache. Linux may remove only <em>clean</em> pages.</p>
<ol class="arabic simple">
<li><p>LRU:                 Keep the last access time and choose the <em>least recently used</em> page</p></li>
<li><p>Two-List Strategy:   Linux keeps two lists - active and inactive. If a page resides in the inactive list and is accessed, then it is placed at the tail of the active.</p></li>
</ol>
</dd>
<dt>Linux’ Page Cache</dt><dd><p>It caches <em>any page-based</em> objects. Hence, a generic object is required - the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code>. It has an operations field - <code class="docutils literal notranslate"><span class="pre">a_ops</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code> has a wrong name. It should be called <code class="docutils literal notranslate"><span class="pre">page_cache_entity</span></code> or <code class="docutils literal notranslate"><span class="pre">physical_pages_of_file</span></code>.</p>
</div>
</div>
<div class="section" id="devices-and-sysfs">
<h2>Devices and sysfs<a class="headerlink" href="#devices-and-sysfs" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>Devices</dt><dd><p>Block
Character
Network
Other - e.g <code class="docutils literal notranslate"><span class="pre">miscdevs</span></code></p>
<p>Some of the device drivers are for virtual devices and only provide access to some kernel functionality (e.g <cite>/dev/urandom</cite>, <cite>/dev/full</cite>, <cite>/dev/null</cite>).</p>
</dd>
<dt>Device Model</dt><dd><p>Able to represent relationships and hierarchy. These structs are embedded in other more interesting things and used in order to represent relationships. Another useful feature placed directly inside <code class="docutils literal notranslate"><span class="pre">kobject</span></code> is reference counting.</p>
</dd>
</dl>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kobject</span></code>:  Equivalent to Java’s <code class="docutils literal notranslate"><span class="pre">Object</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kset</span></code>:     Collection</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ktype</span></code>:    Type of a <code class="docutils literal notranslate"><span class="pre">kobject</span></code> instance</p></li>
</ul>
<img alt="_images/kobjects.png" class="align-center" src="_images/kobjects.png" />
<dl class="simple">
<dt>sysfs</dt><dd><ul class="simple">
<li><p>Each <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span></code> is associated with a dentry in the <cite>/sys</cite> directory.</p></li>
<li><p>Inside <cite>/sys/devices</cite> is stored information related to the underlying system, sorted and separated according to the specific subsystem.</p></li>
<li><p>The directory hierarchy inside <cite>/sys</cite> directly represents the “class relantionships” of all <code class="docutils literal notranslate"><span class="pre">kobject</span></code> s.</p></li>
<li><p>Additionally inside each directory (a <code class="docutils literal notranslate"><span class="pre">kobject</span></code>) there are files which store data related to the specific <code class="docutils literal notranslate"><span class="pre">kobject</span></code> - <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">attribute</span></code> s. Each attribute corresponds to a single concrete value that could be mapped to a primitive C type (or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sysfs</span></code> provides the user with an additional API to the kernel internals.</p></li>
</ul>
</dd>
</dl>
</div>
</div>


              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="index.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">&lt;no title&gt;</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="LittleBookOfSemaphore.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">The Little Book Of Semaphores</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Kristiyan Stoimenov<br/>
        
            &copy; Copyright 2021, Kristiyan Stoimenov.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>